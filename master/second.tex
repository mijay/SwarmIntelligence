\chapter{Построение универсального алгоритма коллективного разума}
\section{Основные подклассы АКР}

Как уже было сказано ранее АКРы достаточно часто разрабатывались по образу и подобию некоторой реально существующей и проявляющей желаемые свойства системы. Фактически из всех АКР могут быть четко выделены несколько групп по критерию происхожднения:
\begin{enumerate}
    \item Алгоритмы моделирующие поведение животных (насекомых, птиц и т.п.), чаще всего стайных/роевых. К этой группе можно отнести уже упомянутые алгоритмы муравейника, улья и многих других. В том числе, алгоритм искуственных иммуных систем \nomenclature{ИИС}{Искуственная Иммуная Система} \cite{ImmuneSystem}, не смотря на то, что в нем моделируется поведение элементарных и несамостоятельных биологических объектов --- клеток имунной системы. Алгоритм SDS также может быть отнесен к этой группе, т.к. изначально он основывался на эмуляции поведения группы людей.
    \item Алгоритмы моделирующие физические процессы. К этой группе принадлежат  уже упомянутый алгоритм GSA, алгоритм Charged System Search \cite{ChargedSearch} и другие.
    \item Полностью искуственные алгоритмы. К этой группе относится PSO и многие его производные.
\end{enumerate}

Подобная классификация, не смотря на ее однозначность и полноту, не представляет никаакого практического интереса, поскольку, как мы покажем далее, алгоритмы, принадлежащие одной группе согласно этой классификации, могут иметь абсолютно разные свойства.

Попробуем разделить класс АКР на группы основываясь на более практически значимых атрибутах, чем происхождение. Для этого рассмотрим некоторые общие свойства алгоритмов этого класса.

Заметим, что АКРы, как и любые АЭМ, представляют свое сосотояние некоторым множеством объектов --- агентами, однако, в алгоритмах класса АКР у агентов есть четко выделенное и всегда проявляющееся свойство: каждому из них в конкретный момент времени сопоставлена координата некоторого пространства. Т.о. мы можем говорить. что <<агенты располагаются в пространстве>>.

На основании вида этого пространства мы можем ввести следующую классификацию АКР:
\begin{enumerate}
    \item Алгоритмы, в которых агенты располагаются в пространстве решений задачи. Например, алгоритм улья.
    \item Алгоритмы, в которых агенты располагаются в пространстве задачи. Например, алгоритм муравейника.
\end{enumerate}

Очевидно, что с точки зрения програмной реализации, алгоритмы этих двух типов существенно различаются. Алгориты первого типа работают в очень большом, потенциально бесконечном пространстве, которое не может целиком быть представленно в памяти приложения. Тогда как алгоритмы второго типа чаще всего (хотя и из этого правила существуют исключения) работают в ограниченом пространстве, все элементы которого могут быть загружены в память.

Следующим критерием, существенно влияющим на практическую реализацию алгоритма, является вид внешних по отношению к агентам данных, с которыми работает алгоритм. Можно выделить три их типа:
\begin{enumerate}
    \item Общая память --- небольшой (полиномиально ограниченный числом агентов) набор некоторых данных, доступных для всех агентов. В простейшем случае --- просто набор нескольких переменных; применяется, например, в PSO. Однако, бывают и более сложные сценарии: в алгоритме ИИС через общие данные передаются широковещательные сообщения.
    \item Пространственная память --- данные ассоциируются с точками пространства. Используется в алгоритме муравейника.
    \item Отсутствие дополнительных данных. Этот тип встречается чаще всего: например, в SDS, алгоритме улья и т.д.
\end{enumerate}

Возможно выделить еще два формальных свойства АКР: локальность и независимость агента. Агенты в алгоримах бывают:
\begin{enumerate}
    \item Локальными, т.е. агент может взаимодействовать (читать/модифицировать ассоциированные данные, перемщаться) с точками в небольшой окрестности своего текущего полажения в пространстве. Таким свойством обладают агенты алгоритма муравейника, ИИС и другие.
    \item Нелокальными. Таковы, например, агенты в PSO и SDS.
\end{enumerate}
\begin{enumerate}
    \item Зависимыми. т.е. состояние агента зависит от состояния других агентов напрямую.
    \item Независимыми, т.е. каждый конкретный агент может взаимодействовать с окружающими лишь опосредованно --- через разделяемые данные.
\end{enumerate}

Стоит отметить, что в алгоритмах с независимыми агентами агенты все равно взаимодействуют друг с другом. Если бы подобного взаимодействия не было, то из АКР пропал бы синергетический эффект большого числа вычислителей. Фактически, алгоритм просто выполнял бы некоторый сценарий поведения (сценарий одного агента) много раз и выбирал лучший результат. Значит, он был бы эквивалентен многократно повторенному стохастическому алгоритму, тело которого совпадает со сценарием агента.

Почему же, не смотря на вышесказанное, агенты называются <<независимыми>>? Дело в том, что обработка каждого агента такого типа не зависит от других агентов в системе: не имеет значения сколько их и в каких состояниях они находятся. В алгоритмах с подобным типом агентов на самом деле даже нет требования синхронного выполнения одной итерации, т.е. пока одни агенты производят вычисления $i$-ый раз, другие уже могут рассчитывать $(i+k)$-ый.

При програмной реализации независимых агентов может возникнуть соблазн сделать выполнение сценария каждого из агентов идеально распараллеливаемым (\cite{ParallelComputing}), однако подобный подход неизбежно приведет к некорректной работе. Дело в том, что сценарий агента формулируется с алгоритмической точки зрения, следовательно, он чувствителен к состоянию гонки (\cite{RaceConditions}). Одним из способов решить эту проблему являеться использование механизма транзакций (\cite{DBBook}).




\section{Анализ иерархии подклассов АКР}\label{sec:hierarhy}
С точки зрения необходимости построения универсального АКР, важным является вопрос анализа сводимости алгоритмов, относящихся к одному подклассу, к алгоритмам из другого подкласса. Действительно, допустим существует иерархия сводимости подклассов АКР:
\begin{center}
    \begin{tikzpicture}
        \node (A) {A};
        \node [below of=A] (B) {B};
        \path [draw, ->] (A) -- (B);
    \end{tikzpicture}
\end{center}
Тогда, очевдино, универсальный АКР может принадлежать только подклассу $B$. Соотвтственно, проанализировав иерархию подклассов мы сможем определить набор свойств, которыми будет обладать универсальный АКР.

Во-первых, рассмотрим свойство локальности. Очевидно, что все АКР с локальными агентами являются также АКР с нелокальными. Покажем, что обратного включения, как и сводимости, нет: пусть есть АКР с пространством $\mathcal{X}$, определенном сложновычислимой монотонной и неограниченной функцией $f: \mathbb{R}\to\mathcal{X}$, при выполнении некоторых условий (напрмиер, при эвристическом признании текущей позиции безперспективной) агент алгоритма осуществляет переход в точку $f(1/\mathrm{Rand}(0,1))$. Очевидно, что в случае такого перехода, агент переместиться в точку лежащую сколь угодно далеко от его текущей позиции и, следовательно, не попадающую ни в какую, сколь угодно большую, ограниченную окрестность текущей позиции.

Во-вторых, рассмотрим классификацию по типу используемых данных. Не требует доказательство тот факт, что алгоритмы без данных сводимы к двум другим подклассам АКР (с общими данными, с пространственными данными), причем, обратного сведения не существует. Рассмотрим подробнее возможности взаимного сведения оставшихся двух подклассов.

Заметим, что в алгоритме с пространственными данными после $m$ итераций потенциально были записаны данные в $\Theta(m*n)$ точек простанства, следовательно, в худшем случае все эти $\Theta(m*n)$ значений необходимо хранить (если они абсолютно случайны и, потому, несжимаемы). В любом алгоритме с общими данными в любой момент времени можно хранить не более чем $p(n)$ значений, следовательно, $\exists M: \Theta(M*n) > p(n)$ $\Rightarrow$ начиная с некоторой итерации $M$ этот алгоритм не сможет хранить данные исходного алгоритма. Это означает, что алгоритмы с общей паматью не сводимы к алгоритмам с пространственной памятью.

Покажем, что по данному АКР с общей памятью можно построить эквивалентный нелокальный АКР с пространственной памятью. Пусть память исходного алгоритма ограничена $p(n)$, тогда всю ее можно представить как одну структуру с полями $1\dotsc p(n)$, или, выражаясь формально, как один символ из алфавита $\Upsilon: \|\Upsilon\|=\|\Sigma\|^{p(n)}$, где $\Sigma$ --- алфавит данных исходного алгоритма. Этот один символ можно записать в данные одной, заранее выделенной, точки пространства, к которой будут иметь доступ все агенты производного АКР, поскольку он является нелокальным.

В-третьих, рассмортим классификацию по свойству независимости агентов. Очевидно, что любой независимый агент может считаться зависимым, следовательно подкласс независимых включается в подкласс зависимыз АКР. Докажем более интересный факт: любой исходный АКР с зависимыми агентам может быть сведен к АКР с общими данными и независмыми агентами. Схема сведения проста: изменим программу исходных агентов так, чтобы по окончанию итерации, они записывали полную информацию о своем состоянии в общие данные алгоритма (каждому агенту в них отведена ровно одна ячейка $\Rightarrow$ свойство ограниченности общего количества ячеек выполняется). Благодаря этому каждый агент вместо того, чтобы взаимодействовать с другими агентами, может просто прочитать полную информацию о них из общих данных.

На основании вышеуказанных построений можно сделать вывод, что универсальный АКР будет обладать свойством нелокальности и пространственной памятью. На свойство зависимости/независимости его агентов никаких теоретических ограничений не накладывается.




\section{Построение универсального АКР}\label{sec:uniAKR}
Построим алгоритм, основанный на общих свойствах класса АКР:

\begin{enumerate}
    \item Алгоритм работает в некотором адрессуемом пространстве (карта), которое определяется следующим образом: $M=(V,E)$ --- карта, если $V$ --- множество точек карты, $E\subseteq V\times V$ --- отношение <<существование перехода>>.\label{enum:space}
    \item С каждой точкой карты и с каждым переходом ассоциированы некоторые данные.
    \item В каждой точке карты расположено некоторое множество (возможно пустое) агентов.
    \item Агенты обладают типом, сценарием и набором данных. Агенты одного типа имеют одинаковый сценарий и одинаковый набор данных (в смысле семантики данных, а не их значений).
    \item Сценарий агента --- это алгоритм, допускающий следующие действия:
    \begin{enumerate}
        \item чтение данных текущего агента;
        \item чтение данных из точек и переходов карты;
        \item запись измененных данных точек и переходов карты;
        \item перемещение текущего агента в другую точку карты;
        \item изменение данных текущего агента.
    \end{enumerate}\label{enum:agent}
    \item Однократное выполнение сценариев всех агентов на карте будем называть ходом. Работа алгоритма сводится к многократному выполнению ходов.
    \item Условие остановки алгоритмом не специфицируется.
    \item Начальное состояние данных дается алгоритму извне, часто все данные изначально считаются нулевыми. Точки, в которых изначально расположены агенты,  обычно выбираются случайно (реже для этого используется эвристика).
    \item Алгоритм стохастический. Генерация случайных чисел (обычно многократная) необходима при обработке каждого агента.
\end{enumerate}

Приведенный алгоритм, очевидно, является АКР с пространственной памятью и нелокальными и независимыми агентами, т.е. он удовлетворяет требованиям, которые мы сформулировали для универсальным АКР. Покажем, что он будет универсальным.

Для любого данного АКР с помощью построений приведенных в \ref{sec:hierarhy} можно построить эквивалентный АКР с нелокальными и независимыми агентами и пространственной памятью. После чего заметим, что в каком бы пространстве (в т.ч. на графах) получившийся алгоритм не был сформулирован, это пространство попадает под определение из (\ref{enum:space}). Аналогично можно утверждать и про сценарии аггентов --- они попадут под ограниения из (\ref{enum:agent}), поскольку АКР в целом является замкнутой системой (нет изменения некоторого внешнего состояния), а в силу независимости и инкапсулированости агентов, любые действия над другими агентами недопустимы.

Таким образом, любой АКР может быть выражен, причем довольно естественно, в терминах подобного универсального АКР, что делает его идеальной моделью для использования в системе поддержки алгоритмов коллективного разума: нам достаточно реализовать поддержку только необходимых универсальному АКР механизмов и мы автоматически получим возможность реализации всех существующих АКР на нашей системе.




\section{Расширения универсального АКР}\label{sec:extendedAKR}
\todo{тут про операции добавления/удаления агентов, добавление локальности и практическое применение}