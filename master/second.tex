\chapter{Построение универсального алгоритма коллективного разума}
\section{Основные подклассы АКР}

Как уже было сказано ранее, АКРы достаточно часто разрабатывались по образу и подобию некоторой реально существующей и проявляющей желаемые свойства системы. Фактически, из всех АКР могут быть четко выделены несколько групп по критерию происхождения:
\begin{enumerate}
    \item Алгоритмы, моделирующие поведение животных (насекомых, птиц и т.п.), чаще всего стайных{\slash}роевых. К этой группе можно отнести уже упомянутые алгоритмы муравейника, улья и многих других. В том числе, алгоритм искусственных иммунных систем \nomenclature{ИИС}{Искусственная Иммунная Система} \cite{ImmuneSystem}, не смотря на то, что в нем моделируется поведение элементарных и несамостоятельных биологических объектов~--- клеток иммунной системы. Алгоритм SDS также может быть отнесен к этой группе, т.к. изначально он основывался на моделировании поведения группы людей.
    \item Алгоритмы, моделирующие физические процессы. К этой группе принадлежат  уже упомянутый алгоритм GSA, алгоритм Charged System Search \cite{ChargedSearch} и другие.
    \item Полностью искусственные алгоритмы. К этой группе относится PSO и многие его производные.
\end{enumerate}

Подобная классификация, не смотря на ее однозначность и полноту, не представляет никакого практического интереса, поскольку, как мы покажем далее, алгоритмы, принадлежащие одной группе согласно этой классификации, могут иметь абсолютно разные свойства.

Попробуем разделить класс АКР на группы, основываясь на более практически значимых атрибутах, чем происхождение. Для этого рассмотрим некоторые общие свойства алгоритмов этого класса.

В разделе \ref{sec:akr} было выделено важнейшее общее свойство АКР~--- наличие пространства, в котором располагаются агенты. На основании вида этого пространства мы можем ввести следующую классификацию АКР:
\begin{enumerate}
    \item Алгоритмы, в которых агенты располагаются в пространстве решений задачи. Например, алгоритм улья.
    \item Алгоритмы, в которых агенты располагаются в пространстве задачи. Например, алгоритм муравейника.
\end{enumerate}

Очевидно, что с точки зрения программной реализации, алгоритмы этих двух типов существенно различаются. Алгоритмы первого типа работают в очень большом, потенциально бесконечном пространстве, которое не может целиком быть представлено в памяти приложения. Тогда как алгоритмы второго типа чаще всего (хотя и из этого правила существуют исключения) работают в ограниченном пространстве, все элементы которого могут быть загружены в память.

Следующим критерием, существенно влияющим на практическую реализацию алгоритма, является вид внешних по отношению к агентам данных, с которыми работает алгоритм. Можно выделить три их типа:
\begin{enumerate}
    \item Общая память~--- небольшой (полиноминально ограниченный числом агентов) набор некоторых данных, доступных всем агентам. В простейшем случае~--- набор нескольких переменных (применяется, например, в PSO). Однако, возможен и более сложный сценарий: данные~--- это буфер для организации широковещательных сообщений (применяется в алгоритме ИИС).
    \item Пространственная память~--- данные ассоциированные с точками пространства. Используется в алгоритме муравейника.
    \item Отсутствие дополнительных данных. Этот тип встречается чаще всего: например, в SDS, алгоритме улья и т.д.
\end{enumerate}

Возможно выделить еще два формальных свойства АКР: локальность и независимость агента. Т.е. агенты в алгоритмах бывают:
\begin{enumerate}
    \item Локальными. Такие агенты могут взаимодействовать (читать{\slash}мо\-ди\-фи\-ци\-ров\-ать ассоциированные данные, данные расположенных агентов, перемещаться) с точками в небольшой окрестности своего текущего положения в пространстве. Таким свойством обладают агенты алгоритма муравейника, ИИС и другие.
    \item Нелокальными. Таковы, например, агенты в PSO и SDS.
\end{enumerate}
\begin{enumerate}
    \item Зависимыми. Состояние таких агентов зависит, в том числе, от состояния окружающих их агентов. Например, агенты в SDS, PSO, GSA.
    \item Независимыми, т.е. такими, что каждый конкретный агент может зависеть от окружающих лишь опосредованно~--- через разделяемые данные. Например, агенты в ИИС.
\end{enumerate}

Стоит отметить, что в алгоритмах с независимыми агентами агенты все равно взаимодействуют друг с другом. Если бы подобного взаимодействия не было, то из АКР пропал бы синергетический эффект большого числа вычислителей. Фактически, алгоритм просто выполнял бы некоторый сценарий поведения (сценарий одного агента) много раз и выбирал лучший результат. Значит, он был бы эквивалентен многократно повторенному стохастическому алгоритму, тело которого совпадает со сценарием агента.

Почему же, не смотря на вышесказанное, агенты называются <<независимыми>>? Дело в том, что обработка каждого агента такого типа не зависит от других агентов в системе: не имеет значения, сколько их и в каких состояниях они находятся. В алгоритмах с подобным типом агентов, на самом деле, даже нет требования синхронного выполнения одной итерации, т.е. пока одни агенты производят вычисления $i$-ый раз, другие уже могут рассчитывать $(i+k)$-ый.

При программной реализации независимых агентов может возникнуть соблазн сделать выполнение сценария каждого из агентов идеально распараллеливаемым (\cite{ParallelComputing}), однако, подобный подход неизбежно приведет к некорректной работе. Дело в том, что сценарий агента формулируется с алгоритмической точки зрения, следовательно, он чувствителен к состоянию гонки (\cite{RaceConditions}). Одним из способов решить эту проблему является использование механизма транзакций (\cite{DBBook}).




\section{Анализ иерархии подклассов АКР}\label{sec:hierarhy}
С точки зрения необходимости построения универсального АКР, важным является вопрос анализа сводимости алгоритмов, относящихся к одному подклассу, к алгоритмам из другого подкласса. Действительно, допустим, что существует иерархия сводимости подклассов АКР:
\begin{center}
    \begin{tikzpicture}
        \node (A) {A};
        \node [below of=A] (B) {B};
        \path [draw, ->] (A) -- (B);
    \end{tikzpicture}
\end{center}
Тогда, очевидно, универсальный АКР может принадлежать только подклассу $B$. Соответственно, проанализировав иерархию подклассов, мы сможем определить набор свойств, которыми будет обладать универсальный АКР.

Во-первых, рассмотрим классификацию по свойству локальности агентов. Очевидно, что все АКР с локальными агентами являются также АКР с нелокальными агентами. Покажем, что обратного включения, как и сводимости, нет.

Пусть есть АКР с пространством $\mathcal{X}$, определенным сложно вычислимой монотонной и неограниченной функцией $f: \mathbb{R}\to\mathcal{X}$. При выполнении некоторых условий (например, при эвристическом признании текущей позиции бесперспективной) агент алгоритма осуществляет переход в точку $f(1/\mathrm{Rand}(0,1))$. Очевидно, что в случае такого перехода, агент переместиться в точку, лежащую сколь угодно далеко от его текущей позиции и, следовательно, не попадающую ни в какую, сколь угодно большую, ее ограниченную окрестность.

Во-вторых, рассмотрим классификацию по типу используемой памяти. Не требует доказательство тот факт, что алгоритмы без памяти сводимы к двум другим подклассам АКР (с общей памятью, с пространственной памятью), причем, обратного сведения не существует. Рассмотрим подробнее возможности взаимного сведения оставшихся двух подклассов.

Заметим, что в алгоритме с пространственной памятью с $n$ агентами после $m$ итераций потенциально были записаны данные в $\Theta(m*n)$ точек пространства, следовательно, в худшем случае все эти $\Theta(m*n)$ значений необходимо хранить (если они абсолютно случайны и, потому, несжимаемы). Попробуем построить алгоритм с общей памятью, который сможет это делать. В любом таком алгоритме в любой момент времени можно хранить не более чем $p(n)$ значений. Т.к. $\exists M: \Theta(M*n) > p(n)$ значит, начиная с некоторой итерации $M$, алгоритм с общей памятью не сможет хранить данные исходного алгоритма. Это означает, что алгоритмы с общей памятью не сводимы к алгоритмам с пространственной памятью.

Покажем, что обратное сведение возможно. Построим по данному АКР с общей памятью эквивалентный нелокальный АКР с пространственной памятью. Пусть память исходного алгоритма ограничена $p(n)$, тогда всю ее можно представить как одну структуру с полями $1\dotsc p(n)$, или, выражаясь формально, как один символ из алфавита $\Upsilon: \|\Upsilon\|=\|\Sigma\|^{p(n)}$, где $\Sigma$~--- алфавит данных исходного алгоритма. Этот один символ можно записать в данные одной, заранее выделенной, точки пространства, к которой будут иметь доступ все агенты производного АКР, поскольку он является нелокальным. Следовательно, производный алгоритм сможет полностью эмулировать работу с памятью.

В-третьих, рассмотрим классификацию по свойству независимости агентов. Очевидно, что любой независимый агент может считаться зависимым. Докажем более интересный факт: любой исходный АКР с зависимыми агентам может быть сведен к АКР с общими данными и независимыми агентами. Схема сведения проста: изменим программу исходных агентов так, чтобы по окончанию итерации, они записывали полную информацию о своем состоянии в общие данные алгоритма (каждому агенту в них отведена ровно одна ячейка $\Rightarrow$ свойство ограниченности общего количества ячеек выполняется). Благодаря этому каждый агент вместо того, чтобы взаимодействовать с другими агентами, может просто читать информацию о них из общих данных.

На основании вышеуказанных построений можно сделать вывод, что универсальный АКР будет обладать свойством нелокальности и пространственной памятью. На свойство зависимости/независимости его агентов никаких теоретических ограничений не накладывается.




\section{Построение универсального АКР}\label{sec:uniAKR}
Построим алгоритм, основанный на общих свойствах класса АКР:

\begin{enumerate}
    \item Алгоритм работает в некотором адресуемом пространстве (карта), которое определяется следующим образом: $M=(V,E)$~--- карта, если $V$~--- множество точек карты, $E\subseteq V\times V$~--- отношение <<существование перехода>>.\label{enum:space}
    \item С каждой точкой карты и с каждым переходом ассоциированы некоторые данные.
    \item В каждой точке карты расположено некоторое множество (возможно пустое) агентов.
    \item Агенты обладают типом, сценарием и набором данных. Агенты одного типа имеют одинаковый сценарий и одинаковый набор данных (в смысле семантики данных, а не их значений).
    \item Сценарий агента~--- это алгоритм, допускающий следующие действия:
    \begin{enumerate}
        \item чтение данных текущего агента;
        \item чтение данных из точек и переходов карты;
        \item запись измененных данных точек и переходов карты;
        \item перемещение текущего агента в другую точку карты;
        \item изменение данных текущего агента.
    \end{enumerate}\label{enum:agent}
    \item Однократное выполнение сценариев всех агентов на карте будем называть ходом. Работа алгоритма сводится к многократному выполнению ходов.
    \item Условие остановки алгоритмом не специфицируется.
    \item Начальное состояние данных дается алгоритму извне, часто все данные изначально считаются нулевыми. Точки, в которых изначально расположены агенты,  обычно выбираются случайно (реже для этого используется эвристика).
    \item Алгоритм стохастический.
\end{enumerate}

Приведенный алгоритм, очевидно, является АКР с пространственной памятью и нелокальными и независимыми агентами, т.е. он удовлетворяет требованиям, которые мы сформулировали для универсального АКР. Покажем, что он будет универсальным.

Для любого данного АКР с помощью построений приведенных в \ref{sec:hierarhy} можно построить эквивалентный АКР с нелокальными и независимыми агентами и пространственной памятью. После чего заметим, что в каком бы пространстве (в том числе на графах) получившийся алгоритм не был сформулирован, это пространство попадает под определение из (\ref{enum:space}). Выполнимость (\ref{enum:agent}) рассмотрим подробнее.

Поскольку АКР в целом является замкнутой системой, следовательно, в сценарии агента нет изменений некоторого внешнего состояния, а могут быть только: изменения состояния данных текущего агента, карты и других агентов, а также перемещение текущего и других агентов в пространстве. Но заметим, что для АКР выполняется унаследованное от АЭМ свойство замкнутости действий одного хода относительно агентов (см. свойства АЭМ на стр. \pageref{EMcommon4}), следовательно, изменение одним агентом состояния другого агента (в том числе перемещение) недопустимо, т.к. тогда его состояние будет изменено более одного раза за ход.

Таким образом, любой АКР может быть выражен, причем довольно естественно, в терминах подобного универсального АКР, что делает его идеальной моделью для использования в системе поддержки алгоритмов коллективного разума: нам достаточно реализовать поддержку только необходимых универсальному АКР механизмов, и мы автоматически получим возможность реализации всех существующих АКР на нашей системе.




\section{Расширения универсального АКР}\label{sec:extendedAKR}
Вышеописанный универсальный АКР подходит для эмуляции любого алгоритма коллективного разума. Однако, если незначительно его расширить, то его возможностей станет достаточно для решения более широкого класса задач.

Рассмотрим первое возможное расширение. Пусть в сценариях агентов будет допустимы две дополнительные операции: добавление нового агента на карту и удаление текущего агента. Вместе с этими операциями универсальный АКР, очевидно, может эмулировать поведение таких систем, как игра <<Жизнь>> (\cite{GameLive}) и большинства агент-ориентированных систем моделирования, например, системы социальной симуляции (\cite{SocialSim}). Причем, никакие из полезных свойств универсального АКР (нелокальность, независимость и т.д.) не будут нарушены.

Следующее естественное расширение универсального АКР~--- это добавление ограничения на перемещение агентов. Поскольку на карте $G=(V,E)$ определено понятие перехода, следовательно, на ней определяется понятие достижимости точки $b \in V$ из точки $a \in V$ ($\exists e_1,\dotsc, e_n \in E: e_1=(a,a_1),\dotsc, e_n=(a_{n-1},b)$) и перехода $c \in E$ из точки $a \in V$ ($\exists e_1,\dotsc, e_n \in E, a' \in V: e_1=(a, a_1), \dotsc, e_n=(a_{n-1},a_n), c=(a_n, a')$). Опираясь на эти понятия можно добавить следующее ограничение на сценарий агента: все точки и переходы, данные которых агент читает и модифицирует, а также точки, в которые он перемещается, должны быть достижимы из точки, в которой находится агент. Подобное ограничение позволяет естественнее выражать на языке универсального АКР многие задачи. Кроме того, благодаря ему можно проще формализовать требование к локальности агентов.
