\chapter{Практическая реализация}\label{sec:second}
\section{Требования к системе поддержки}
Целью работы была разработка системы поддержки произвольных АКР. Как уже было сказано в разделе \ref{sec:uniAKR} в качестве модели, диктующей требования для этой системы, естественно было бы использовать универсальный АКР. Также, с позиции увеличения области применимости системы, было решено при разработке учитывать расширения модели описанные в разделе \ref{sec:extendedAKR}.

Поскольку планируется будущее использование системы поддержки АКР в работе лаборатории РВИиМАП, в том числе в рамках спецкурса Нейронные Сети, то к ее реализации были предъявлены некоторые дополнительные требования.
\begin{itemize}
    \item Система должна быть написана на языке C\# и работать на платформе .NET, поскольку остальные разработки лаборатории выполняются с помощью этих технологий.
    \item Необходимо обеспечить низкий порог вхождения, посокльку система будет использоваться студентами. Следовательно, используемый способ описания АКР должен быть выразительным и простым в изучении.
    \item Система должна позволять решать стандартые задачи минимальными усилиями, поскольку планиеруется ее использование в учебном процессе. Это, помимо вышеперечисленного, требует наличия дополнительных средств, облегчающих решение типовых задач. В идеале небольшие задачи-примеры должны занимать всего несколько строк.
    \item Система должна быть легко расширяемой и, при этом, показывать неплохую производительность.
\end{itemize}

На основании вышепревиденных требований было принято решение, что все компоненты АКР будут, в рамках системы поддержки, описываться непосредственно на языке C\#. Подобный подход обеспечивает низкий порог вхождения, простоту интеграции с другими решениями и легкость в расширении системы.




\section{Представление карты в програмной модели}\label{sec:spaceArch}
Для разработки системы необходимо, в перевую очередь, четко определить, чем будет являться модель АКР в тех же терминах, в которых будет описана и сама система, т.е. в терминах объектно-ориентированной \nomenclature{ОО}{Объектно Ориентированный} (\cite{ObjectOriented}) архитектуры (\cite{SoftwareArchitecture}). Сформулировать из каких компонентов она будет сосотоять, и как они будут взаимодействовать.

В первую очередь необходимо определить самое базовое понятие любого АКР --- карту. Напомним, что карта $M=(V,E)$, где $V$ --- множество точек карты, $E \subseteq V \times V$ --- отношение <<существование перехода>> (может рассматриваться как множество переходов --- пар $(v_1,v_2) \in E$). В АКР карта выполняет одновременно четыре роли: во-первых, точки карты являются способом адресации пространства, используемым для описания алгоритмов агентов и АКР в целом; во-вторых, карта обеспечаивает топологию пространства, ограниченвая возможности для перемещения{\textfractionsolidus}взаимдействия агентов; в-третьих, в точках карты располагаются агенты; и, в-четвертых, точки и переходы карты являются носителями данных.

В нашей реализации все функции карты будут разнесены в разные сущности, как того требует Single Responsibility Principle \nomenclature{SRP}{Single Responsibility Principle} \cite{SRP}. Кроме того, подобное разделение эффективно в связи с абсолютно разными сценариями использования разных ролей карты: точка карты, как координата, должна быть строго неизменяемой (\cite{ImmutableObject}), легковестной и клонируеммой сущностью, поскольку активно используется в вычислениях и адресациях. В тоже время очевидно, что точка как вместилище агентов должна быть изменяемой.

Первой роли карты --- адресации пространства, мы сопоставим сущность называемую координатой. В системе она будет отражена следующим интерфейсом:

\begin{cscode}
public interface ICoordinate<TCoordinate>: IEquatable<TCoordinate>, ICloneable<TCoordinate>
    where TCoordinate: ICoordinate<TCoordinate>
{
}
\end{cscode}

Интерфейс поддерживает основные операции, допустимые над координатами: сравнение двух координат на равенство и копирование. Другие возможные свойства координат, такие как: сравнение, вычисление расстояния, алгебраические операции --- не включены в интерфейс, поскольку не являются достаточно общими (не во всех картах эти операции имеют смысл) либо не пригождаются в системе.

По приведенному фрагменту кода видно, что в базовой архитектуре приложения заложены принципы активного использования обобщенных типов \cite{DotNet4} и техники параметрического наследования (англ. curiously recurring template pattern) \nomenclature{CRTP}{Curiously Recurring Template Pattern} \cite{CRTP}, на них основаной. Подробнее причины использования этих подходов в сиситеме будут описаны в разделе \ref{sec:why}.

Продолжим рассмотрение програмных сущностей, соответствующих теоретическому понятию <<карта>>. Следующая роль --- обеспечение топологии пространства. В системе она будет отражена следующим базовым классом:

\begin{cscode}
public abstract class Topology<TCoordinate>
    where TCoordinate: ICoordinate<TCoordinate>
{
    // реализация методов опущена для краткости
    public abstract bool Lays(TCoordinate coord);
    public abstract IEnumerable<TCoordinate> GetSuccessors(TCoordinate coord);
    public abstract IEnumerable<TCoordinate> GetPredecessors(TCoordinate coord);
    public virtual bool Lays(Edge<TCoordinate> edge) {}
    public virtual IEnumerable<TCoordinate> GetAdjacent(TCoordinate coord) {}
    public IEnumerable<Edge<TCoordinate>> GetOutgoing(TCoordinate coord) {}
    public IEnumerable<Edge<TCoordinate>> GetIncoming(TCoordinate coord) {}
    public IEnumerable<Edge<TCoordinate>> GetAdjacentEdges(TCoordinate coord) {}
}
\end{cscode}

Топология обладает парными методами для \verb!TCoordinate! и \linebreak\verb!Edge<TCoordinate>!, который является предсталением перехода. Топология позволяет проверять лежит ли данная точка{\textfractionsolidus}переход на карте; получить по точке список последующих точек (таких, в которые из нее можно перейти) и наоборот --- предшествующих.

Третья роль карты --- размещение агентов в ее точках. Это роль существенно более комплексная, поэтому будет описана отдельно в разделе \ref{sec:map+cells}.

Четвертая роль --- размещение данных в точках и переходах карты. Она реализуется посредством двух интерфейсов: слоя данных точек и переходов соответственно.

\begin{cscode}
public interface IEdgesDataLayer<TCoordinate, TEdgeData>:
        ICompleteMapping<Edge<TCoordinate>, TEdgeData>
    where TCoordinate: ICoordinate<TCoordinate>
{
    Topology<TCoordinate> Topology { get; }
}

public interface INodesDataLayer<TCoordinate, TNodeData>:
        ICompleteMapping<TCoordinate, TNodeData>
	where TCoordinate: ICoordinate<TCoordinate>
{
    Topology<TCoordinate> Topology { get; }
}
\end{cscode} 

Общий предок этих интерфейсов \verb!ICompleteMapping<TKey,TValue>! --- это интерфейс, описывающий всюду определенное отображение из ключей типа \verb!TKey! в значения типа \verb!TValue!. Опуская детали реализации, нужные в основном ради переиспользования кода, этот интерфейс имеет следующий вид:

\begin{cscode}
public interface ICompleteMapping<in TKey, TValue>
{
    TValue Get(TKey key);
    void Set(TKey key, TValue value);
}
\end{cscode}

То есть слой данных: во-первых, привязан к топологии карты (это нужно для обеспечения корректных внешних контрактов класса, см. раздел \ref{sec:why}) и, во-вторых, умеет по произвольной точке{\textfractionsolidus}переходу карты возвращать либо устанавливать ассоциированные с ним данные. Заметим, что реализовать такой интерфейс просто как поверх поставщиков статических данных, напрмер таковым будет слой данных, читающий данные из двумерного изображения и выбрасывающий исключение \verb!NotSupportedException! при попытке записи в него, так и поверх обычных хранилищ данных, снабженных операцией генерации начального значения данных в точке.




\section{Использование обобщенных типов в системе}\label{sec:why}
По выдержкам кода, приведенным в разделе \ref{sec:spaceArch}, можно заметить, что в системе активно исполльзуются обобщенные типы. Фактически, почти вся система параметризована тремя тип-параметрами: \verb!TCoordinate!, \verb!TNodeData!, \verb!TEdgeData!. Эти параметры определяют, соответственно, тип координаты, используемой в системе, тип данных ассоциированых с точками пространства и тип данных ассоциированый с переходами.

Использование обощенных типов дает несколько существенных преимуществ. Покажем их на следующем примере.

Пусть у нас есть интерфейс описывающий некий стандартный компонент системы, реализация которой будет задаче-специфична (таковым будет, в частности, компонент представляющий агента). Публичный интерфейс этого компонента почти наверняка будет использовать передачу координат. Пользуясь стандартным техникой dependency inversion  \nomenclature{DIP}{Dependency Inversion Principle} \cite{DIP} мы могли бы получить следующий интерфейс компонента:

\begin{cscode}
public interface IComponent
{
    void Method(ICoordinate coord);
}
\end{cscode}

Теперь попробуем представить себе его реализацию. Т.к. компонент задаче-специфичный, то, очевидно, что он будет разрабатываться с учетом условий конкретной задачи, в том числе, с расчетом на работу только в пространстве фиксированого вида и, следовательно, с фиксироваными типом координат. Значит, его код будет иметь следующий вид:

\begin{cscode}
public class Component: IComponent
{
    public void Method(ICoordinate coord)
    {
        var point = (Coordinate2D) coord;
        // некоторый код
    }
}
\end{cscode}

Такой код обладает сразу несколькими недостатками. Он слаботипизированый (\cite{TypeSystem}), следовательно ошибки связанные с неправильным использованием компонента не будут выявлены компилятором во время проверки типов, а обнаружатся только во время исполнения. Он основывается на неявных контрактах, т.е. формально на уровне языка никак не отражено, что этот компонент может работать только в системах с координатой типа \verb!Coordinate2D!. Более того, требование к типу координат невозможно отразить даже с помощью средств контрактного программирования (\cite{Contracts}), поскольку эти требования в терминах контрактов являются предусловиями, а предусловия могут быть определены только в объясвлении высшего уровня (в нашем случае --- в интерфейсе \verb!IComponent!) дабы не противоречить принципу Лисков \cite{Liskov}.

В дополнение ко всему вышеперечисленному, приведенный выше код имеет проблемы с производительностью. Дело в том, что операция приведения типов на платформе .NET имеет достаточно высокие накладные расходы \cite{Casting}, а в приведенном примере она будет проводиться по крайней мере дважды. Но, что более существенно, поскольку чаще всего координаты --- это преддставляемые структурами примитивные значения, то операция приведения типов будет приводить к боксингу \cite{CSharpStandard}, накладные расходы на который огромны.

Вышеперечисленных проблем можно избежать, если представить интерфейс и реализацию компонента в следующем виде:

\begin{cscode}
public interface IComponent<TCoordinate>
    where TCoordinate: ICoordinate
{
    void Method(TCoordinate coord);
}

public class Component: IComponent<Coordinate2D>
{
    public void Method(Coordinate2D coord)
    {
        // некоторый код
    }
}

public class AbstractComponent<TCoordinate>: IComponent<TCoordinate>
    where TCoordinate: ICoordinate
{
    public void Method(TCoordinate coord)
    {
        // некоторый код
    }
}

public class OtherComponent
{
    public void Method2<TCoordinate>(TCoordinate coord)
        where TCoordinate: ICoordinate
    {
        // некоторый код
    }
}
\end{cscode}

При подобном подходе возможно, во-первых, явно указывать, что все методы компонента работают с координтатой одного типа, что актуально для большинства компонентов; во-вторых, возможно указывать, что конкретный компонент может работать только с конкретным типом координат; в-третьих, не возникает проблем при написании абстрактных компонентов, которые могут работать с любыми типами координат (\verb!AbsctractComponent<TCoordinate>! в примере), и компонентов, методы которых могут работать с разными типами координат (\verb!OtherComponent! в примере). Кроме того, благодаря механизму реализации обощенных типов в .NET, во всех вышеприведенных случаях генерируется оптимальный для каждой ситуации код без приведения типов и боксинга.

Недостатками вышеописанного подхода можно считать необходимость написания дополнительного кода в декларации каждого типа и накладные расходы на первый вызов обобщенных типов и методов, связанные с механизмом конкретизации обобщенных типов в .NET.

При проектировании системы, после анализа вышеприведенных недостатков и преимуществ  использования тип-параметров, было решено использовать их только для базовых компонентов, которые могут быть представлены структурами, т.е. для координат и данных ассоциированых с точками и с переходами пространства.

Еще одной техникой используемой при проектрировании системы была CRTP \cite{CRTP}. Ее использование приводит к появлению следующих контструкций в описании интерфейсов:

\begin{cscode}
public interface ICoordinate<T>
    where T: ICoordinate<T>
{
    // некоторые методы
}
\end{cscode}

Единственный способ корректно реализовать подобный интерфейс следующий:

\begin{cscode}
public struct GraphCoordinate: ICoordinate<GraphCoordinate>
{
    // некоторые поля и методы
}
\end{cscode}

В чем преимущество использования этой техники? Во время реализации системы оказалось, что достаточно много компонентов могут быть реализованы (полностью или частично) без привязки к конкретному типу координат. В коде подобных карто-независимых компонентов часто было нужно проводить простейшие операции над координатами, а именно --- сравнение на равенство. Стандартный способ сделать сравнение, это вызвать метод \lstinline!bool Equals(object other)!, определенный для каждого объекта. Однако, можно заметить, что при таком подходе мы получаем те-же самые недостатки, как и при описании компонентов без использования обобщенных типов: невозможно указать, что координаты можно сравнивать только с координатами такого-же типа; невозможно указать, что в реализации \verb!ICoordinate! обязательно нужно переопределять операцию сравнение; необходимость писать лишний код в реализации сравнения; существенные проблемы с производительностью.

Техника CRTP позволяет избежать этих проблем. Мы можем определить интерфейс следующим образом:

\begin{cscode}
public interface ICoordinate<T>
    where T: ICoordinate<T>
{
    bool Equals(T other);
}
\end{cscode}

Тогда в каждом из его реализаций необходимо будет реализовать метод \verb!Equals!, принимающий в качестве аргумента объект с типом равным типу самой реализации:

\begin{cscode}
public struct GraphCoordinate: ICoordinate<GraphCoordinate>
{
    public bool Equals(GraphCoordinate other)
    {
        // некоторый код
    }
}
\end{cscode}

Очевидно, подобный подход решает все вышеописанные проблемы.



\section{Использование контрактов в системе}
По мере реализации системы стало понятно, что в ее компонентах возникает очень большое число ограний на входные параметры методов. В качестве самого часто встречающегося примера можно привести проверку допустимости координаты: т.е. проверку того, что переданая координата вообще лежит в текущей карте.

В результате система начала содержать слишком много проверочного кода, котрый во-первых затруднял чтение исходников и, во-вторых, оказывал негативное влияние на производительность системы. Действительно, та-же операция проверки принадлежности точки карте может быть достаточно нетривиальной.

В качестве решения этой проблемы было решено использовать библиотеку контрактного программирования для платформы .NET --- CodeContracts \cite{CodeContracts} и специализированный инструментарий для нее. С помощью этой библиотеки стало возможным вынести все проверки входных данных в блоки вида \lstinline!Contract.Requres(arg != null)!, либо в отдельные классы, воспользовшись техникой разделения контракта и ограничеваемого типа.

В результате код контрактов стал отделен от кода логики (в случае использования отдельных классов-контрактов), либо стал отличим визуально (инструментарий библиотеки CodeContracts интегрируется в среду разработки и подсвечивает особым образом контракты в коде). Также существенным преимуществом является то, что включение{\textfractionsolidus}отключение проверок контрактов делается исключительно через настройки сборки проекта. Кроме того использование контрактов уменьшило дублируемость проверок: если раньше проверки входных данных необходимо было делать в каждой реализации интерфейса или перегрузке метода, то теперь проверки должны быть написаны ровно в одном месте. Также контракты полезны с точки зрения документирования кода, т.к. существуют автоматические средства включающие информацию о контрактах в сгенерированную документацию и кроме того, существует явное требования формализовать все контракты.

В дальнейшей работе к написанию предусловий методов --- контрактов на аргументы и публичное состояние компонентов --- добавились еще и постусловия. Их использование оказалось полезным с точки зрения автоматической валидации кода на этапе компиляции: CodeContracts пытается статически доказать все ограничения, ктоторые были описаны в коде и, если какие-то из них нарушаются, то это приводит к ошибке этапа компиляции. Подобное раннее обнаружение ошибок оказалось достаточно полезной функциональностью.

Необходимость описывать контракты для методов во всех компонентах системы также позволяет яснее представлять зависимости и связности компонентов. В частности, уже отмеченный ранее факт, что многие компоненты системы содержат в себе поле \verb!Topology!, объясняется именно необходимостью проверять внутри предусловий методово корректность переданых в качестве аргументов значений координат \verb!TCoordinate! и переходов \verb!Edge<TCoordinate>!. Также можно отметить, что описаный ранее метод \lstinline!ICoordinate<T>.Equals(T other)! чаще всего используется в пост- и предусловиях.




\section{Размещения агентов на карте}\label{sec:map+cells}
Вернемся к рассмотрению представления карты как хранилища агентов с точки зрения програмной модели. Програмное представление этой роли также называется картой и выполняет функцию хранения ячеек карты. Ячейка карты --- програмная модель точки карты в смысле контейнера для размещения агентов.

Описание интерфейса агента будет дано позже --- в разделе \ref{sec:agents}. Для текущего описания нам достаточно знать, что этот интерфейс имеет следующую сигнатуру:
\lstinline!public interface IAnt<TCoordinate, TNodeData, TEdgeData>!.

Приведем интерфейс ячейки карты:

\begin{cscode}
public interface ICell<TCoordinate, TNodeData, TEdgeData>:
        IEnumerable<IAnt<TCoordinate, TNodeData, TEdgeData>>
    where TCoordinate: ICoordinate<TCoordinate>
{
    IMap<TCoordinate, TNodeData, TEdgeData> Map { get; }
    TCoordinate Coordinate { get; }
}
\end{cscode}

Он довлольно естественный: ячейка умеет перечислять находящихся в ней агентов и знает то, в какой точке какой карты она расположена.

Интерфейс карты представляет больший интерес:

\begin{cscode}
public interface IMap<TCoordinate, TNodeData, TEdgeData>:
        ISparsedMapping<TCoordinate, ICell<TCoordinate, TNodeData, TEdgeData>>
    where TCoordinate: ICoordinate<TCoordinate>
{
    Topology<TCoordinate> Topology { get; }
}

public interface ISparsedMapping<TKey, TValue>:
        IEnumerable<KeyValuePair<TKey, TValue>>
{
    bool TryGet(TKey key, out TValue value);
}
\end{cscode}

Легко заметить, что одно из основных свойств интерфейса --- обеспечение разреженного хранения ячеек. Очевидно, что не имеет смысла держать в памяти представления тех ячеек, в которых на данный момент отсутствуют агенты. Заметим, что в интерфейсе \verb!IDataLayer!, который, как кажется естественным, должен быть аналогичен \verb!IMap!, используется прямо противоположный подход --- в нем (с точки зрения потребителя) одновременно храняться данные \textit{всех} точек пространства.

Изначально поведения \verb!IMap! и \verb!IDataLayer! были аналогичными, однако после проведения экспериментов над прототипом системы стало понятно, что не смотря на общую схожетсть функциональности этих двух компонентов, сценарии их использования существенно отличаются.

Для \verb!IDataLayer! справедливо утверждение, что если в определенную точку пространства данные ни разу не записывались, то при чтении из нее мы получим некоторое значение по умолчанию. Поскольку данные ячеек на практике почти всегда представляются неизменяемыми структурами (существенно реже --- неизменяемыми объектами; использование изменяемых типов данных в качестве представления данных ячеек имеет очень ограниченную область применимости), то хранение подобного значения по умолчанию становится нецелесообразным --- его гораздо легче сконструировать на лету, точнее, нужно ровно один раз его создать, закешировать и возвращать всегда закешированое значение.















