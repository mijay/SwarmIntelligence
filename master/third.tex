\chapter{Практическая реализация}\label{sec:second}
\section{Требования к системе поддержки}
Целью работы была разработка системы поддержки произвольных АКР. Как уже было сказано в разделе \ref{sec:uniAKR}, в качестве модели, диктующей требования для этой системы, естественно было бы использовать универсальный АКР. Также, с позиции увеличения области применимости системы, было решено при разработке учитывать расширения модели, описанные в разделе \ref{sec:extendedAKR}.

Поскольку планируется будущее использование системы поддержки АКР в работе лаборатории РВИиМАП, в том числе в рамках спецкурса Нейронные Сети, то к ее реализации были предъявлены некоторые дополнительные требования.
\begin{itemize}
    \item Система должна быть написана на языке C\# и работать на платформе .NET, поскольку остальные разработки лаборатории выполняются с помощью этих технологий.
    \item Необходимо обеспечить низкий порог вхождения, поскольку система будет использоваться студентами. Следовательно, используемый способ описания АКР должен быть выразительным и простым в изучении.
    \item Система должна позволять решать стандартные задачи минимальными усилиями, поскольку планируется ее использование в учебном процессе. Это, помимо вышеперечисленного, требует наличия дополнительных средств, облегчающих решение типовых задач. В идеале небольшие задачи-примеры должны занимать всего несколько строк.
    \item Система должна быть легко расширяемой и, при этом, показывать неплохую производительность.
\end{itemize}

На основании вышеприведённых требований было принято решение, что все компоненты АКР будут, в рамках системы поддержки, описываться непосредственно на языке C\#. Подобный подход обеспечивает низкий порог вхождения, простоту интеграции с другими решениями и легкость в расширении системы.




\section{Представление карты в программной модели}\label{sec:spaceArch}
Для разработки системы необходимо четко определить, чем будет являться модель АКР в тех же терминах, в которых будет описана и сама система, т.е. в терминах объектно-ориентированной \nomenclature{ОО}{Объектно-Ориентированный} (\cite{ObjectOriented}) архитектуры (\cite{SoftwareArchitecture}). Сформулировать из каких компонентов она будет состоять, и как они будут взаимодействовать.

В первую очередь необходимо определить самое базовое понятие любого АКР~--- карту. Напомним, что карта $M=(V,E)$, где $V$~--- множество точек карты, $E \subseteq V \times V$~--- отношение <<существование перехода>> (может рассматриваться как множество переходов~--- пар $(v_1,v_2) \in E$). В АКР карта выполняет одновременно четыре роли: во-первых, точки карты являются способом адресации пространства, используемым для описания алгоритмов агентов и АКР в целом; во-вторых, карта обеспечивает топологию пространства, ограничевая возможности для перемещения{\slash}взаимодействия агентов; в-третьих, в точках карты располагаются агенты; и, в-четвертых, точки и переходы карты являются носителями данных.

В нашей реализации все функции карты будут разнесены в разные сущности, как того требует Single Responsibility Principle \nomenclature{SRP}{Single Responsibility Principle} \cite{SRP}. Кроме того, подобное разделение эффективно в связи с абсолютно разными сценариями использования разных ролей карты. Например, точка карты, как координата, должна быть строго неизменяемой (\cite{ImmutableObject}), легковесной и клонируемой сущностью, поскольку активно используется в вычислениях и адресациях. В тоже время очевидно, что точка, как вместилище агентов или данных, таковыми свойствами обладать не должна.

Первой роли карты~--- адресации пространства, мы сопоставим сущность, называемую координатой. Координата~--- это адрес одной точки карты. В системе она будет отражена следующим интерфейсом:

\begin{cscode}
public interface ICoordinate<TCoordinate>: IEquatable<TCoordinate>, ICloneable<TCoordinate>
    where TCoordinate: ICoordinate<TCoordinate>
{
}
\end{cscode}

Интерфейс поддерживает основные операции, допустимые над координатами: сравнение двух координат на равенство и копирование. Другие возможные свойства координат, такие как: сравнение, вычисление расстояния, алгебраические операции~--- не включены в интерфейс, поскольку не являются достаточно общими (не во всех картах эти операции имеют смысл), либо не используются в системе.

По приведенному фрагменту кода видно, что в базовой архитектуре приложения заложены принципы активного использования обобщенных типов \cite{DotNet4} и техники параметрического наследования (англ. curiously recurring template pattern) \nomenclature{CRTP}{Curiously Recurring Template Pattern} \cite{CRTP}, на них основаной. Подробнее причины использования этих подходов в системе будут описаны в разделе \ref{sec:why}.

Продолжим рассмотрение программных сущностей, соответствующих теоретическому понятию <<карта>>. Следующая роль~--- обеспечение топологии пространства. В системе она будет отражена следующим базовым классом:

\begin{cscode}
public abstract class Topology<TCoordinate>
    where TCoordinate: ICoordinate<TCoordinate>
{
    // реализация методов опущена для краткости
    public abstract bool Lays(TCoordinate coord);
    public abstract IEnumerable<TCoordinate> GetSuccessors(TCoordinate coord);
    public abstract IEnumerable<TCoordinate> GetPredecessors(TCoordinate coord);
    public virtual bool Lays(Edge<TCoordinate> edge) {}
    public virtual IEnumerable<TCoordinate> GetAdjacent(TCoordinate coord) {}
    public IEnumerable<Edge<TCoordinate>> GetOutgoing(TCoordinate coord) {}
    public IEnumerable<Edge<TCoordinate>> GetIncoming(TCoordinate coord) {}
    public IEnumerable<Edge<TCoordinate>> GetAdjacentEdges(TCoordinate coord) {}
}
\end{cscode}

Топология обладает парными методами для \verb!TCoordinate! и \linebreak\verb!Edge<TCoordinate>!, который является представлением перехода. Топология позволяет проверять, лежит ли данная точка{\slash}переход на карте; получить по точке список последующих точек (таких, в которые из нее можно перейти) и наоборот~--- предшествующих.

Третья роль карты~--- размещение агентов в ее точках. Реализация этой роль существенно более сложная, поэтому будет описана отдельно в разделе \ref{sec:map+cells}.

Четвертая роль~--- размещение данных в точках и переходах карты. Она реализуется посредством двух интерфейсов: слоя данных точек и переходов соответственно.

\begin{cscode}
public interface IEdgesDataLayer<TCoordinate, TEdgeData>:
        ICompleteMapping<Edge<TCoordinate>, TEdgeData>
    where TCoordinate: ICoordinate<TCoordinate>
{
    Topology<TCoordinate> Topology { get; }
}

public interface INodesDataLayer<TCoordinate, TNodeData>:
        ICompleteMapping<TCoordinate, TNodeData>
	where TCoordinate: ICoordinate<TCoordinate>
{
    Topology<TCoordinate> Topology { get; }
}
\end{cscode} 

Общий предок этих интерфейсов \verb!ICompleteMapping<TKey,TValue>!~--- это интерфейс, описывающий всюду определенное отображение из ключей типа \verb!TKey! в значения типа \verb!TValue!. Интерфейс имеет следующий вид:

\begin{cscode}
public interface ICompleteMapping<in TKey, TValue>
{
    TValue Get(TKey key);
    void Set(TKey key, TValue value);
}
\end{cscode}

То есть слой данных: во-первых, привязан к топологии карты (это нужно для обеспечения корректных внешних контрактов класса, см. раздел \ref{sec:contracts}) и, во-вторых, умеет по произвольной точке{\slash}переходу карты возвращать либо устанавливать ассоциированные с ним данные. Заметим, что реализовать такой интерфейс просто как поверх поставщиков статических данных, например таковым будет слой данных, читающий данные из двумерного изображения и выбрасывающий исключение \verb!NotSupportedException! при попытке записи в него, так и поверх обычных хранилищ данных, снабженных операцией генерации начального значения данных в точке.




\section{Использование обобщенных типов в системе}\label{sec:why}
По выдержкам кода, приведенным в разделе \ref{sec:spaceArch}, можно заметить, что в системе активно используются обобщенные типы. Фактически, почти вся система параметризована тремя тип-параметрами: \verb!TCoordinate!, \verb!TNodeData!, \verb!TEdgeData!. Эти параметры определяют, соответственно, тип координаты, используемой в системе, тип данных, ассоциированных с точками пространства, и тип данных, ассоциированных с переходами.

Использование обобщенных типов дает несколько существенных преимуществ. Покажем их на примере.

Пусть у нас есть интерфейс, описывающий некий стандартный компонент системы, реализация которой будет задаче-специфична (таковым будет, в частности, компонент представляющий агента). Публичный интерфейс этого компонента почти наверняка будет использовать передачу координат. Пользуясь стандартной техникой dependency inversion  \nomenclature{DIP}{Dependency Inversion Principle} \cite{DIP} мы могли бы получить следующий интерфейс компонента:

\begin{cscode}
public interface IComponent
{
    void Method(ICoordinate coord);
}
\end{cscode}

Теперь попробуем представить себе его реализацию. Т.к. компонент задаче-специфичный, то, очевидно, что он будет разрабатываться с учетом условий конкретной задачи, в том числе, с расчетом на работу только в пространстве фиксированного вида и, следовательно, с фиксированными типом координат. Значит, его код будет иметь следующий вид:

\begin{cscode}
public class Component: IComponent
{
    public void Method(ICoordinate coord)
    {
        var point = (Coordinate2D) coord;
        // некоторый код
    }
}
\end{cscode}

Такой код обладает сразу несколькими недостатками. Он слаботипизированый (\cite{TypeSystem}), следовательно, ошибки связанные с неправильным использованием компонента не будут выявлены компилятором во время проверки типов, а обнаружатся только во время исполнения. Он основывается на неявных контрактах, т.е. формально на уровне языка никак не отражено, что этот компонент может работать только в системах с координатой типа \verb!Coordinate2D!. Более того, требование к типу координат невозможно отразить даже с помощью средств контрактного программирования (\cite{Contracts}), поскольку эти требования в терминах контрактов являются предусловиями, а предусловия могут быть определены только в объявлении высшего уровня (в нашем случае~--- в интерфейсе \verb!IComponent!), дабы не противоречить принципу Лисков \cite{Liskov}.

В дополнение ко всему вышеперечисленному, приведенный код имеет проблемы с производительностью. Дело в том, что операция приведения типов на платформе .NET имеет достаточно высокие накладные расходы \cite{Casting}, а в приведенном примере она будет проводиться, по крайней мере, дважды. Но, что более существенно, поскольку чаще всего координаты~--- это представляемые структурами примитивные значения, то операция приведения типов будет приводить к упаковке{\slash}распаковке значений \cite{CSharpStandard}, накладные расходы которых огромны.

Вышеперечисленных проблем можно избежать, если представить интерфейс и реализацию компонента в следующем виде:

\begin{cscode}
public interface IComponent<TCoordinate>
    where TCoordinate: ICoordinate
{
    void Method(TCoordinate coord);
}

public class Component: IComponent<Coordinate2D>
{
    public void Method(Coordinate2D coord)
    {
        // некоторый код
    }
}

public class AbstractComponent<TCoordinate>: IComponent<TCoordinate>
    where TCoordinate: ICoordinate
{
    public void Method(TCoordinate coord)
    {
        // некоторый код
    }
}

public class OtherComponent
{
    public void Method2<TCoordinate>(TCoordinate coord)
        where TCoordinate: ICoordinate
    {
        // некоторый код
    }
}
\end{cscode}

При подобном подходе возможно, во-первых, явно указывать, что все методы компонента работают с координатой одного типа, что актуально для большинства компонентов; во-вторых, возможно указывать, что конкретный компонент может работать только с конкретным типом координат; в-третьих, не возникает проблем при написании абстрактных компонентов, которые могут работать с любыми типами координат (\verb!AbsctractComponent<TCoordinate>! в примере), и компонентов, методы которых могут работать с разными типами координат (\verb!OtherComponent! в примере). Кроме того, благодаря механизму реализации обобщенных типов в .NET, во всех вышеприведенных случаях генерируется оптимальный для каждой ситуации код без приведения типов и упаковки{\slash}распаковки.

Недостатками вышеописанного подхода можно считать необходимость написания дополнительного кода в декларации каждого типа и накладные расходы на первый вызов обобщенных типов и методов, связанные с механизмом конкретизации обобщенных типов в .NET.

При проектировании системы, после анализа вышеприведенных недостатков и преимуществ  использования тип-параметров, было решено использовать их только для базовых компонентов, которые могут быть представлены структурами, т.е. для координат и данных, ассоциированных с точками и с переходами пространства.

Еще одной техникой, используемой при проектировании системы, была CRTP \cite{CRTP}. Ее использование приводит к появлению следующих конструкций в описании интерфейсов:

\begin{cscode}
public interface ICoordinate<T>
    where T: ICoordinate<T>
{
    // некоторые объявлления
}
\end{cscode}

Единственный способ корректно реализовать подобный интерфейс следующий:

\begin{cscode}
public struct GraphCoordinate: ICoordinate<GraphCoordinate>
{
    // реализация
}
\end{cscode}

В чем преимущество использования этой техники? Во время реализации системы оказалось, что достаточно много компонентов могут быть реализованы (полностью или частично) без привязки к конкретному типу координат. В коде подобных компонентов часто было нужно проводить простейшие операции над координатами, а именно~--- сравнение на равенство. Стандартный способ сделать сравнение, это вызвать метод \lstinline!bool Equals(object other)!, определенный для каждого объекта. Однако, можно заметить, что при таком подходе мы получаем те же самые недостатки, как и при описании компонентов без использования обобщенных типов: невозможно указать, что координаты можно сравнивать только с координатами такого же типа; невозможно указать, что в реализации \verb!ICoordinate! обязательно нужно переопределять операцию сравнение; необходимость писать лишний код в реализации сравнения; существенные проблемы с производительностью.

Техника CRTP позволяет избежать этих проблем. Мы можем определить интерфейс следующим образом:

\begin{cscode}
public interface ICoordinate<T>
    where T: ICoordinate<T>
{
    bool Equals(T other);
}
\end{cscode}

Тогда в каждом из его реализаций необходимо будет реализовать метод \verb!Equals!, принимающий в качестве аргумента объект с типом, равным типу самой реализации:

\begin{cscode}
public struct GraphCoordinate: ICoordinate<GraphCoordinate>
{
    public bool Equals(GraphCoordinate other)
    {
        // некоторый код
    }
}
\end{cscode}

Очевидно, подобный подход решает все вышеописанные проблемы.



\section{Использование контрактов в системе}\label{sec:contracts}
По мере реализации системы стало понятно, что в ее компонентах возникает очень большое число ограничений на входные параметры методов. В качестве самого часто встречающегося примера можно привести проверку допустимости координаты: т.е. проверку того, что переданная координата вообще лежит в текущей карте.

В результате система начала содержать слишком много проверочного кода, который, во-первых, затруднял чтение исходников и, во-вторых, оказывал негативное влияние на производительность системы. Действительно, та же операция проверки принадлежности точки карте может быть достаточно нетривиальной.

В качестве решения этой проблемы было решено использовать библиотеку контрактного программирования для платформы .NET~--- CodeContracts \cite{CodeContracts} и специализированный инструментарий для нее. С помощью этой библиотеки стало возможным вынести все проверки входных данных в блоки вида \lstinline|Contract.Requres(arg != null)|, либо в отдельные классы, воспользовавшись техникой разделения контракта и ограничиваемого типа.

В результате код контрактов стал отделен от кода логики (в случае использования отдельных классов-контрактов), либо стал отличим визуально (инструментарий библиотеки CodeContracts интегрируется в среду разработки и выделяет особым образом контракты в коде). Также существенным преимуществом является то, что включение{\slash}отключение проверок контрактов делается исключительно через настройки сборки проекта. Кроме того, использование контрактов уменьшило дублируемость проверок: если раньше проверки входных данных необходимо было делать в каждой реализации интерфейса или перегрузке метода, то теперь проверки должны быть написаны ровно в одном месте~--- при первом объявлении метода{\slash}свойства. Также контракты полезны с точки зрения документирования кода, т.к. существуют автоматические средства, включающие информацию о контрактах в сгенерированную документацию, и, кроме того, существует явное требования формализовать все контракты.

В дальнейшей работе, помимо описания предусловий методов: контрактов на аргументы и публичное состояние компонента~--- стали описываться еще и постусловия. Их использование оказалось полезным с точки зрения автоматической проверки кода на этапе компиляции: CodeContracts пытается статически доказать все ограничения, которые были описаны в коде и, если какие-то из них нарушаются, то это приводит к ошибке этапа компиляции. Подобное раннее обнаружение ошибок оказалось достаточно полезной функциональностью.

Необходимость описывать контракты для методов во всех компонентах системы также позволяет яснее представлять зависимости и связности компонентов. В частности, уже отмеченный ранее факт, что многие компоненты системы содержат в себе поле \verb!Topology! (реже \verb!Map!), объясняется именно необходимостью проверять внутри предусловий методов корректность переданных в качестве аргументов значений координат \verb!TCoordinate! и переходов \verb!Edge<TCoordinate>!. Также можно отметить, что описанный ранее метод \lstinline!ICoordinate<T>.Equals(T other)! чаще всего используется в пост- и пред-условиях.




\section{Представление агента в программной модели}\label{sec:agents}
Вернемся к рассмотрению программной модели системы. Рассмотрим ее важнейшую компоненту~--- агента. Агент~--- это единственная активная сущность в АКР, одновременно с этим, сущность, которую будут программно реализовывать чаще всего. Более того, фактически, агент~--- это единственный компонент, который надо реализовывать при решении каждой задачи, остальные чаще всего будут переиспользоваться. Поэтому к удобству реализации интерфейса агента предъявляются особые требования. Приведем этот интерфейс:

\begin{cscode}
public interface IAnt<TCoordinate, TNodeData, TEdgeData>
    where TCoordinate: ICoordinate<TCoordinate>
{
    TCoordinate Coordinate { get; }
    ICell<TCoordinate, TNodeData, TEdgeData> Cell { get; }
    void ProcessTurn();
}
\end{cscode}

Кажется очевидным, что компонент, единственная функция которого~--- выполнять одно действие, должен иметь ровно один метод и ничего более. Тем не менее, в вышеприведенном интерфейсе это не так. Рассмотрим подробнее причины подобного отступления от традиционных принципов проектирования.

Чрезвычайно важным нюансом является то, что агент должен обладать некоторой информацией о своем текущем состоянии, в том числе и о своем текущем положении в пространстве. Будет достаточно неестественно, если информацию о координате должен будет отслеживать разработчик конечного агента, т.к. во всех остальных ситуациях система берет на себя всю работу по манипуляциям с пространством. Фактически, если мы переложим ответственность за отслеживание положения агента на пользователя библиотеки поддержки, то мы нарушим инкапсуляцию (\cite{GoF}) системы и создадим почву для возникновения ошибок.

Следовательно, информацию о текущей координате агента должна отслеживать и передавать агенту система поддержки. Способов подобной передачи несколько: через аргументы метода и через поля{\slash}свойства. Передача через аргументы кажется более естественной с точки зрения архитектуры приложения, однако после экспериментов над прототипом системы стало понятно, что подобный подход достаточно неудобен. Дело в том, что чаще всего состояние агента хранится в его полях и используется при вычислениях из различных private методов. В результате все переданные из системы в агента данные о его положении либо немедленно складываются в поля, либо начинают обрабатываться совершенно иным способом, нежели остальная информация о состоянии. Чтобы избегать подобных неестественностей, было принято решение передавать информацию о координате через поля агента.




\section{Размещения агентов на карте}\label{sec:map+cells}
Размещение агентов~--- это одна из ролей, которую выполняет карта в терминах модели АКР. Как уже было сказано в разделе \ref{sec:spaceArch}, каждой такой роли в реализации системы отводится отдельная сущность. Для карты, как контейнера агентов, таковой программной сущностью является карта (в дальнейшем, чтобы различать <<карту>> в терминах модели АКР, от <<карты>> в программной модели, будем называть первую <<пространством>>). Карта хранит ячейки, которые являются программными моделями точек пространства в смысле контейнера для размещения агентов.

Приведем интерфейс ячейки карты:

\begin{cscode}
public interface ICell<TCoordinate, TNodeData, TEdgeData>:
        IEnumerable<IAnt<TCoordinate, TNodeData, TEdgeData>>
    where TCoordinate: ICoordinate<TCoordinate>
{
    IMap<TCoordinate, TNodeData, TEdgeData> Map { get; }
    TCoordinate Coordinate { get; }
}
\end{cscode}

Он довольно естественный: ячейка умеет перечислять находящихся в ней агентов и знает то, в какой точке какой карты она расположена.

Интерфейс карты представляет больший интерес:

\begin{cscode}
public interface IMap<TCoordinate, TNodeData, TEdgeData>:
        ISparsedMapping<TCoordinate, ICell<TCoordinate, TNodeData, TEdgeData>>
    where TCoordinate: ICoordinate<TCoordinate>
{
    Topology<TCoordinate> Topology { get; }
}

public interface ISparsedMapping<TKey, TValue>:
        IEnumerable<KeyValuePair<TKey, TValue>>
{
    bool TryGet(TKey key, out TValue value);
}
\end{cscode}

Легко заметить, что одно из основных свойств интерфейса~--- обеспечение разреженного хранения ячеек. Почему именно разреженного? Очевидно, что не имеет смысла держать в памяти представления тех ячеек, в которых на данный момент отсутствуют агенты. Тем не менее, в интерфейсе \verb!IDataLayer!, который, как кажется естественным, должен быть аналогичен \verb!IMap!, используется прямо противоположный подход~--- в нем (с точки зрения потребителя) одновременно хранится данные \textit{всех} точек пространства.

Изначально поведения \verb!IMap! и \verb!IDataLayer! были аналогичными, однако после проведения экспериментов над прототипом системы стало понятно, что несмотря на общую схожесть функциональности этих двух компонентов, сценарии их использования существенно отличаются.

Для \verb!IDataLayer! справедливо утверждение, что если в определенную точку пространства данные ни разу не записывались, то при чтении из нее мы получим некоторое значение по умолчанию, которое естественным образом будет использоваться в наших алгоритмах. Например, в расчетах нового значения данных, нам нужно знать старое, тогда удобно считать, что если старого значения не было, то оно равно значению по умолчанию~--- 0. Соответственно, для потребителя интерфейса было бы удобно никогда не думать про случай <<отсутствующего значения>>, а работать с \verb!IDataLayer!, как со всюду-определенным отображением.

Более того, подобный интерфейс можно легко реализовать без дополнительных накладных расходов. Поскольку данные ячеек на практике почти всегда представляются неизменяемыми структурами (существенно реже~--- неизменяемыми объектами; использование изменяемых типов в качестве представления данных ячеек имеет очень ограниченную область применимости), следовательно, нет необходимости хранить значение по умолчанию для каждой точки (более того, на картах с бесконечным количеством точек пришлось бы хранить бесконечное множество экземпляров этого значения), можно просто сконструировать его один раз и при запросах возвращать мемоизированное значение \cite{Memoisation}.

Для \verb!IMap! подобная техника не эффективна, поскольку содержимое карты~--- это ячейки, которые представляют ценность только как контейнер для агентов. Соответственно, код, использующий карту, обычно построен следующим образом:

\begin{algorithmic}
    \ForAll{$i \in \{\, v \mid v \in V, \exists (\mathrm{current}, v) \in E \,\}$}
        \ForAll{$ agent \in \mathrm{Agents}(i)$}
            \State do something with $agent$
        \EndFor
    \EndFor
\end{algorithmic}

Очевидно, что в рамках такого кода возвращение <<ячейки по умолчанию>> бессмысленно и неэффективно. В связи с этим, в системе для \verb!IMap! был выбран противоположный к \verb!IDataLayer! подход: возвращать только ячейки, реально содержащие данные, причем, даже если в карте хранится пустая ячейка, то она никогда не будет возвращена на запрос \lstinline!map.TryGet(ccordinate, out cell)! и на \lstinline!map.GetEnumerator()!.




\section{Особенности реализации системы}
Ранее были рассмотрены базовые интерфейсы, позволяющие описать произвольный АКР и его пространство вместе с ассоциированными данными. Эти интерфейсы являются основополагающими в системе, однако, очевидно, сами по себе никаких прикладных задач они не решают. Фактически, они представляют абстрактную часть системы~--- сборку \verb!SwarmIntelligence.Core!.

Непосредственно код, выполняющий функции по поддержке карты, ячеек, слоев данных и логгированию~--- все абстрагируемые от конкретной задачи функции, находится в другой сборке: \verb!SwarmIntelligence.Engine!. Этот код достаточно сложен и учитывает множество нюансов, таких как распараллеливание операций с помощью семейства технологий TPL \cite{Parallel} и PLINQ \cite{PLINQ}, конкурентный доступ к данным с помощью Concurrent Collections \cite{ConcurrentCollections}, сборка мусора и повторное использование объектов \cite{ObjectPool} (поскольку выделение памяти под новые объекты~--- дорогостоящая операция в среде .NET, то переиспользование объектов дает существенный прирост производительности).

Типы из \verb!SwarmIntelligence.Engine! являются реализациями интерфейсов из \verb!SwarmIntelligence.Core! и предполагают, что все сущности в системе будут их наследниками. Причина этого в том, что интерфейсы слоев данных, карты и ячейки являются сильно связанными, вследствие этого их реализации так же сильно связны. Например, агент умеет выполнять действие <<перейти в точку>>. Оно реализуется следующим образом:

\begin{cscode}
    ICell<TCoordinate, TNodeData, TEdgeData> fromCell;
    if(!map.TryGet(ant.Coordinate, out fromCell))
        throw new AssertionException();

    var targetCell = map.GetOrCreate(to);
    
    fromCell.Remove(ant);
    targetCell.Add(ant);
    ant.Coordinate = target;
\end{cscode}

Понятно, что присвоение координаты агенту, удаление и добавление агента в ячейки невозможно через описанные ранее интерфейсы. Решение построить систему именно таким образом, было принято после нескольких экспериментов с различными архитектурами. В результате решение, максимально скрывающее аспекты своей реализации, а значит и менее предрасполагающее конечных разработчиков к ошибкам, было признанно наиболее успешным. Поэтому, все нюансы, связанные с прямым добавлением{\slash}удалением агентов из ячеек, ячеек в карту и т.п. были исключены из публичных интерфейсов.

Стоит отметить, что следствием вышеприведенного решения является то, что все публичные интерфейсы \verb!SwarmIntelligence.Core! не позволяют менять состояние агентов на карте. Причина в том, что набор модифицирующих операций сильно зависит от реализации интерфейсов. В частности, реализация, максимально использующая распараллеливание, не может позволить себе операцию удаления агента, распределенная~--- операции, выполняемые в произвольной точке пространства и т.д.

Существующий сейчас \verb!SwarmIntelligence.Engine! позволяет перемещать текущего агента, создавать нового в произвольной точке и самоуничтожать агента.




\section{Событийная модель}
Очевидно, что промежуточный результат работы системы должен некоторым образом экспортироваться для использования средств визуализации текущего состояния (\cite{Visualization}), сбора статистики, логгирования, серализации (\cite{Serialization}) и других.

Естественным решением этой задачи является вызов специализированого кода раз в несколько ходов системы. Этот код, в свою очередь, пользуясь существующими публичными интерфейсами системы (представленными \verb!SwarmIntelligence.Core!), строил бы полное представление ее текущего состояния и передавал бы его в подсистемы визуализации, сбора статистики и прочие <<обозревающие>> (англ. observing) подсистемы.

Подобный подход был опробован на практике и был признан неподходящим по нескольким причинам: во-первых, высокое время задержки между событием и информированием обозревающих подсистем о нем; во-вторых, неравномерность производительности системы, вызванная периодическим запуском <<тяжелых>> обозревающих подсистем; в-третьих, неудобство расширения протокола взаимодействия алгоритмов и обозревающих его подсистем.

Текущее решение использует событийно-ориентированный подход \cite{EventDriven}. Каждый компонент системы, будь то агенты, карта или вспомогательные классы из \verb!SwarmIntelligence.Engine! имеют доступ к экземпляру интерфейса \verb!ILog!, обеспечивающему операции записи сообщений в программный лог. Сообщение~--- это кортеж, состоящий из строки, характеризующей тип сообщения, и произвольного количества дополнительных параметров.

Помимо типа \verb!ILog! существует тип \verb!ILogManager!, предоставляющий событийный интерфейс чтения лога. Фактически, после того как некоторое сообщение будет <<добавлено в лог>> посредством \verb!ILog!, оно будет чрезвычайно быстро (что важно с точки зрения минимизации влияния на производительность основного алгоритма) записано в легковесный потоко-безопасный буфер. Периодически выделенный поток вычитывает текущее состояние этого буфера и с помощью событий интерфейса \verb!ILogManager! сообщает всем потребителям о том, что пришла новая группа сообщений.

Подобный подход позволяет уменьшить время задержки между событием и информированием обозревающих систем о нем благодаря тому, что теперь подобное информирование происходит не раз в фиксированное число ходов, а по мере наличия вычислительных ресурсов. Кроме того, гораздо легче стало расширять протокол взаимодействия рабочего и обозревающего кода: фактически, все что теперь нужно~--- это добавить новый тип сообщений и начать генерировать и обрабатывать его в новом коде, причем старый код это изменение не разрушит. Дополнительно преимущество такого подхода~--- распараллеливание обозревающего и рабочего кода.




\section{Библиотека решений}
Помимо непосредственно системы поддержки АКР~--- \linebreak\verb!SwarmIntelligence.Engine!, была также реализована библиотека стандартных решений~--- \verb!SwarmIntelligence.Library!, включающая в себя реализации множества переиспользуемых компонентов. В том числе: карты и координаты для трехмерного мерного 6- и 24-связного пространства, для двумерного 4- и 8-связного пространства, для графов. Были реализованы агенты, поддерживающие удаленное уничтожение, и операция над агентами <<уничтожить данного агента>>.

Одна из интересных функций, вошедших в состав \linebreak\verb!SwarmIntelligence.Library!~--- это реализация сборки системы на основе конфигурации. Фактически, это узкоспециализированый Dependency Injection Container \cite{DI}, учитывающий нюансы приложения. К сожалению, стандартные утилиты для решения этой задачи (например, \cite{Ninject}) были признаны неподходящими, в связи с активным использованием в системе обобщенных типов и некоторых других нюансов, приводивших к чрезвычайно сложному конфигурационному коду для сторонних утилит.





