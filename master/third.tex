\chapter{Практическая реализация}\label{sec:second}
\section{Требования к системе поддержки}
Целью работы была разработка системы поддержки произвольных АКР. Как уже было сказано в разделе \ref{sec:uniAKR} в качестве модели, диктующей требования для этой системы, естественно было бы использовать универсальный АКР. Также, с позиции увеличения области применимости системы, было решено при разработке учитывать расширения модели описанные в разделе \ref{sec:extendedAKR}.

Поскольку планируется будущее использование системы поддержки АКР в работе лаборатории РВИиМАП, в том числе в рамках спецкурса Нейронные Сети, то к ее реализации были предъявлены некоторые дополнительные требования.
\begin{itemize}
    \item Система должна быть написана на языке C\# и работать на платформе .NET, поскольку остальные разработки лаборатории выполняются с помощью этих технологий.
    \item Необходимо обеспечить низкий порог вхождения, посокльку система будет использоваться студентами. Следовательно, используемый способ описания АКР должен быть выразительным и простым в изучении.
    \item Система должна позволять решать стандартые задачи минимальными усилиями, поскольку планиеруется ее использование в учебном процессе. Это, помимо вышеперечисленного, требует наличия дополнительных средств, облегчающих решение типовых задач. В идеале небольшие задачи-примеры должны занимать всего несколько строк.
    \item Система должна быть легко расширяемой и, при этом, показывать неплохую производительность.
\end{itemize}

На основании вышепревиденных требований было принято решение, что все компоненты АКР будут, в рамках системы поддержки, описываться непосредственно на языке C\#. Подобный подход обеспечивает низкий порог вхождения, простоту интеграции с другими решениями и легкость в расширении системы.




\section{Представление карты в програмной модели}\label{sec:spaceArch}
Для разработки системы необходимо, в перевую очередь, четко определить, чем будет являться модель АКР в тех же терминах, в которых будет описана и сама система, т.е. в терминах объектно-ориентированной \nomenclature{ОО}{Объектно Ориентированный} (\cite{ObjectOriented}) архитектуры (\cite{SoftwareArchitecture}). Сформулировать из каких компонентов она будет сосотоять, и как они будут взаимодействовать.

В первую очередь необходимо определить самое базовое понятие любого АКР --- карту. Напомним, что карта $M=(V,E)$, где $V$ --- множество точек карты, $E \subseteq V \times V$ --- отношение <<существование перехода>> (может рассматриваться как множество переходов --- пар $(v_1,v_2) \in E$). В АКР карта выполняет одновременно четыре роли: во-первых, точки карты являются способом адресации пространства, используемым для описания алгоритмов агентов и АКР в целом; во-вторых, карта обеспечаивает топологию пространства, ограниченвая возможности для перемещения{\slash}взаимдействия агентов; в-третьих, в точках карты располагаются агенты; и, в-четвертых, точки и переходы карты являются носителями данных.

В нашей реализации все функции карты будут разнесены в разные сущности, как того требует Single Responsibility Principle \nomenclature{SRP}{Single Responsibility Principle} \cite{SRP}. Кроме того, подобное разделение эффективно в связи с абсолютно разными сценариями использования разных ролей карты. Например, точка карты, как координата, должна быть строго неизменяемой (\cite{ImmutableObject}), легковестной и клонируеммой сущностью, поскольку активно используется в вычислениях и адресациях. В тоже время очевидно, что точка как вместилище агентов или данных таковыми свойствами обладать не должна.

Первой роли карты --- адресации пространства, мы сопоставим сущность называемую координатой. Координата --- это адрес одной точки карты. В системе она будет отражена следующим интерфейсом:

\begin{cscode}
public interface ICoordinate<TCoordinate>: IEquatable<TCoordinate>, ICloneable<TCoordinate>
    where TCoordinate: ICoordinate<TCoordinate>
{
}
\end{cscode}

Интерфейс поддерживает основные операции, допустимые над координатами: сравнение двух координат на равенство и копирование. Другие возможные свойства координат, такие как: сравнение, вычисление расстояния, алгебраические операции --- не включены в интерфейс, поскольку не являются достаточно общими (не во всех картах эти операции имеют смысл) либо не используются в системе.

По приведенному фрагменту кода видно, что в базовой архитектуре приложения заложены принципы активного использования обобщенных типов \cite{DotNet4} и техники параметрического наследования (англ. curiously recurring template pattern) \nomenclature{CRTP}{Curiously Recurring Template Pattern} \cite{CRTP}, на них основаной. Подробнее причины использования этих подходов в сиситеме будут описаны в разделе \ref{sec:why}.

Продолжим рассмотрение програмных сущностей, соответствующих теоретическому понятию <<карта>>. Следующая роль --- обеспечение топологии пространства. В системе она будет отражена следующим базовым классом:

\begin{cscode}
public abstract class Topology<TCoordinate>
    where TCoordinate: ICoordinate<TCoordinate>
{
    // реализация методов опущена для краткости
    public abstract bool Lays(TCoordinate coord);
    public abstract IEnumerable<TCoordinate> GetSuccessors(TCoordinate coord);
    public abstract IEnumerable<TCoordinate> GetPredecessors(TCoordinate coord);
    public virtual bool Lays(Edge<TCoordinate> edge) {}
    public virtual IEnumerable<TCoordinate> GetAdjacent(TCoordinate coord) {}
    public IEnumerable<Edge<TCoordinate>> GetOutgoing(TCoordinate coord) {}
    public IEnumerable<Edge<TCoordinate>> GetIncoming(TCoordinate coord) {}
    public IEnumerable<Edge<TCoordinate>> GetAdjacentEdges(TCoordinate coord) {}
}
\end{cscode}

Топология обладает парными методами для \verb!TCoordinate! и \linebreak\verb!Edge<TCoordinate>!, который является предсталением перехода. Топология позволяет проверять лежит ли данная точка{\slash}переход на карте; получить по точке список последующих точек (таких, в которые из нее можно перейти) и наоборот --- предшествующих.

Третья роль карты --- размещение агентов в ее точках. Это роль существенно более комплексная, поэтому будет описана отдельно в разделе \ref{sec:map+cells}.

Четвертая роль --- размещение данных в точках и переходах карты. Она реализуется посредством двух интерфейсов: слоя данных точек и переходов соответственно.

\begin{cscode}
public interface IEdgesDataLayer<TCoordinate, TEdgeData>:
        ICompleteMapping<Edge<TCoordinate>, TEdgeData>
    where TCoordinate: ICoordinate<TCoordinate>
{
    Topology<TCoordinate> Topology { get; }
}

public interface INodesDataLayer<TCoordinate, TNodeData>:
        ICompleteMapping<TCoordinate, TNodeData>
	where TCoordinate: ICoordinate<TCoordinate>
{
    Topology<TCoordinate> Topology { get; }
}
\end{cscode} 

Общий предок этих интерфейсов \verb!ICompleteMapping<TKey,TValue>! --- это интерфейс, описывающий всюду определенное отображение из ключей типа \verb!TKey! в значения типа \verb!TValue!. Интерфейс имеет следующий вид:

\begin{cscode}
public interface ICompleteMapping<in TKey, TValue>
{
    TValue Get(TKey key);
    void Set(TKey key, TValue value);
}
\end{cscode}

То есть слой данных: во-первых, привязан к топологии карты (это нужно для обеспечения корректных внешних контрактов класса, см. раздел \ref{sec:contracts}) и, во-вторых, умеет по произвольной точке{\slash}переходу карты возвращать либо устанавливать ассоциированные с ним данные. Заметим, что реализовать такой интерфейс просто как поверх поставщиков статических данных, напрмер таковым будет слой данных, читающий данные из двумерного изображения и выбрасывающий исключение \verb!NotSupportedException! при попытке записи в него, так и поверх обычных хранилищ данных, снабженных операцией генерации начального значения данных в точке.




\section{Использование обобщенных типов в системе}\label{sec:why}
По выдержкам кода, приведенным в разделе \ref{sec:spaceArch}, можно заметить, что в системе активно исполльзуются обобщенные типы. Фактически, почти вся система параметризована тремя тип-параметрами: \verb!TCoordinate!, \verb!TNodeData!, \verb!TEdgeData!. Эти параметры определяют, соответственно, тип координаты, используемой в системе, тип данных ассоциированых с точками пространства и тип данных ассоциированый с переходами.

Использование обощенных типов дает несколько существенных преимуществ. Покажем их на примере.

Пусть у нас есть интерфейс описывающий некий стандартный компонент системы, реализация которой будет задаче-специфична (таковым будет, в частности, компонент представляющий агента). Публичный интерфейс этого компонента почти наверняка будет использовать передачу координат. Пользуясь стандартным техникой dependency inversion  \nomenclature{DIP}{Dependency Inversion Principle} \cite{DIP} мы могли бы получить следующий интерфейс компонента:

\begin{cscode}
public interface IComponent
{
    void Method(ICoordinate coord);
}
\end{cscode}

Теперь попробуем представить себе его реализацию. Т.к. компонент задаче-специфичный, то, очевидно, что он будет разрабатываться с учетом условий конкретной задачи, в том числе, с рассчетом на работу только в пространстве фиксированого вида и, следовательно, с фиксироваными типом координат. Значит, его код будет иметь следующий вид:

\begin{cscode}
public class Component: IComponent
{
    public void Method(ICoordinate coord)
    {
        var point = (Coordinate2D) coord;
        // некоторый код
    }
}
\end{cscode}

Такой код обладает сразу несколькими недостатками. Он слаботипизированый (\cite{TypeSystem}), следовательно ошибки связанные с неправильным использованием компонента не будут выявлены компилятором во время проверки типов, а обнаружатся только во время исполнения. Он основывается на неявных контрактах, т.е. формально на уровне языка никак не отражено, что этот компонент может работать только в системах с координатой типа \verb!Coordinate2D!. Более того, требование к типу координат невозможно отразить даже с помощью средств контрактного программирования (\cite{Contracts}), поскольку эти требования в терминах контрактов являются предусловиями, а предусловия могут быть определены только в объясвлении высшего уровня (в нашем случае --- в интерфейсе \verb!IComponent!) дабы не противоречить принципу Лисков \cite{Liskov}.

В дополнение ко всему вышеперечисленному, приведенный код имеет проблемы с производительностью. Дело в том, что операция приведения типов на платформе .NET имеет достаточно высокие накладные расходы \cite{Casting}, а в приведенном примере она будет проводиться по крайней мере дважды. Но, что более существенно, поскольку чаще всего координаты --- это преддставляемые структурами примитивные значения, то операция приведения типов будет приводить к успаковке{\slash}распаковке значений \cite{CSharpStandard}, накладные расходы которых огромны.

Вышеперечисленных проблем можно избежать, если представить интерфейс и реализацию компонента в следующем виде:

\begin{cscode}
public interface IComponent<TCoordinate>
    where TCoordinate: ICoordinate
{
    void Method(TCoordinate coord);
}

public class Component: IComponent<Coordinate2D>
{
    public void Method(Coordinate2D coord)
    {
        // некоторый код
    }
}

public class AbstractComponent<TCoordinate>: IComponent<TCoordinate>
    where TCoordinate: ICoordinate
{
    public void Method(TCoordinate coord)
    {
        // некоторый код
    }
}

public class OtherComponent
{
    public void Method2<TCoordinate>(TCoordinate coord)
        where TCoordinate: ICoordinate
    {
        // некоторый код
    }
}
\end{cscode}

При подобном подходе возможно, во-первых, явно указывать, что все методы компонента работают с координтатой одного типа, что актуально для большинства компонентов; во-вторых, возможно указывать, что конкретный компонент может работать только с конкретным типом координат; в-третьих, не возникает проблем при написании абстрактных компонентов, которые могут работать с любыми типами координат (\verb!AbsctractComponent<TCoordinate>! в примере), и компонентов, методы которых могут работать с разными типами координат (\verb!OtherComponent! в примере). Кроме того, благодаря механизму реализации обощенных типов в .NET, во всех вышеприведенных случаях генерируется оптимальный для каждой ситуации код без приведения типов и успаковки{\slash}распаковки.

Недостатками вышеописанного подхода можно считать необходимость написания дополнительного кода в декларации каждого типа и накладные расходы на первый вызов обобщенных типов и методов, связанные с механизмом конкретизации обобщенных типов в .NET.

При проектировании системы, после анализа вышеприведенных недостатков и преимуществ  использования тип-параметров, было решено использовать их только для базовых компонентов, которые могут быть представлены структурами, т.е. для координат и данных ассоциированых с точками и с переходами пространства.

Еще одной техникой используемой при проектрировании системы была CRTP \cite{CRTP}. Ее использование приводит к появлению следующих контструкций в описании интерфейсов:

\begin{cscode}
public interface ICoordinate<T>
    where T: ICoordinate<T>
{
    // некоторые объявлления
}
\end{cscode}

Единственный способ корректно реализовать подобный интерфейс следующий:

\begin{cscode}
public struct GraphCoordinate: ICoordinate<GraphCoordinate>
{
    // реализация
}
\end{cscode}

В чем преимущество использования этой техники? Во время реализации системы оказалось, что достаточно много компонентов могут быть реализованы (полностью или частично) без привязки к конкретному типу координат. В коде подобных компонентов часто было нужно проводить простейшие операции над координатами, а именно --- сравнение на равенство. Стандартный способ сделать сравнение, это вызвать метод \lstinline!bool Equals(object other)!, определенный для каждого объекта. Однако, можно заметить, что при таком подходе мы получаем те-же самые недостатки, как и при описании компонентов без использования обобщенных типов: невозможно указать, что координаты можно сравнивать только с координатами такого-же типа; невозможно указать, что в реализации \verb!ICoordinate! обязательно нужно переопределять операцию сравнение; необходимость писать лишний код в реализации сравнения; существенные проблемы с производительностью.

Техника CRTP позволяет избежать этих проблем. Мы можем определить интерфейс следующим образом:

\begin{cscode}
public interface ICoordinate<T>
    where T: ICoordinate<T>
{
    bool Equals(T other);
}
\end{cscode}

Тогда в каждом из его реализаций необходимо будет реализовать метод \verb!Equals!, принимающий в качестве аргумента объект с типом равным типу самой реализации:

\begin{cscode}
public struct GraphCoordinate: ICoordinate<GraphCoordinate>
{
    public bool Equals(GraphCoordinate other)
    {
        // некоторый код
    }
}
\end{cscode}

Очевидно, подобный подход решает все вышеописанные проблемы.



\section{Использование контрактов в системе}\label{sec:contracts}
По мере реализации системы стало понятно, что в ее компонентах возникает очень большое число ограний на входные параметры методов. В качестве самого часто встречающегося примера можно привести проверку допустимости координаты: т.е. проверку того, что переданая координата вообще лежит в текущей карте.

В результате система начала содержать слишком много проверочного кода, котрый во-первых затруднял чтение исходников и, во-вторых, оказывал негативное влияние на производительность системы. Действительно, та-же операция проверки принадлежности точки карте может быть достаточно нетривиальной.

В качестве решения этой проблемы было решено использовать библиотеку контрактного программирования для платформы .NET --- CodeContracts \cite{CodeContracts} и специализированный инструментарий для нее. С помощью этой библиотеки стало возможным вынести все проверки входных данных в блоки вида \lstinline|Contract.Requres(arg != null)|, либо в отдельные классы, воспользовшись техникой разделения контракта и ограничеваемого типа.

В результате код контрактов стал отделен от кода логики (в случае использования отдельных классов-контрактов), либо стал отличим визуально (инструментарий библиотеки CodeContracts интегрируется в среду разработки и выделяет особым образом контракты в коде). Также существенным преимуществом является то, что включение{\slash}отключение проверок контрактов делается исключительно через настройки сборки проекта. Кроме того использование контрактов уменьшило дублируемость проверок: если раньше проверки входных данных необходимо было делать в каждой реализации интерфейса или перегрузке метода, то теперь проверки должны быть написаны ровно в одном месте --- при первом объявлении метода{\slash}свойства. Также контракты полезны с точки зрения документирования кода, т.к. существуют автоматические средства включающие информацию о контрактах в сгенерированную документацию и кроме того, существует явное требования формализовать все контракты.

В дальнейшей работе помимо описания предусловий методов: контрактов на аргументы и публичное состояние компонента --- стали описыватся еще и постусловия. Их использование оказалось полезным с точки зрения автоматической валидации кода на этапе компиляции: CodeContracts пытается статически доказать все ограничения, ктоторые были описаны в коде и, если какие-то из них нарушаются, то это приводит к ошибке этапа компиляции. Подобное раннее обнаружение ошибок оказалось достаточно полезной функциональностью.

Необходимость описывать контракты для методов во всех компонентах системы также позволяет яснее представлять зависимости и связности компонентов. В частности, уже отмеченный ранее факт, что многие компоненты системы содержат в себе поле \verb!Topology! (реже \verb!Map!), объясняется именно необходимостью проверять внутри предусловий методово корректность переданых в качестве аргументов значений координат \verb!TCoordinate! и переходов \verb!Edge<TCoordinate>!. Также можно отметить, что описаный ранее метод \lstinline!ICoordinate<T>.Equals(T other)! чаще всего используется в пост- и предусловиях.




\section{Представление агента в програмной модели}\label{sec:agents}
Вернемся к рассмотрению програмной модели системы. Рассмотрим ее важнейшую компоненту --- агента. Агент --- это единственная активная сущность в АКР, одновременно с этим, сущность, которую будут програмное реализовывать чаще всего. Более того, фактически, агент --- это единственный компонент, который надо реализовывать при решении каждой задачи, остальные чаще всего будут переиспользоваться. По этому, к удобству реализации интерфейса агента предъявляются особые требования. Приведем этот интерфейс:

\begin{cscode}
public interface IAnt<TCoordinate, TNodeData, TEdgeData>
    where TCoordinate: ICoordinate<TCoordinate>
{
    TCoordinate Coordinate { get; }
    ICell<TCoordinate, TNodeData, TEdgeData> Cell { get; }
    void ProcessTurn();
}
\end{cscode}

Кажется очевидным, что компонент, есдинственная функция которого --- выполнять одно действие, должен иметь ровно один метод и ничего более. Тем не менее в вышеприведенном интерфейсе это не так. Рассмотрим подробнее причины подобного отступления от традиционных принципов проектирования.

Чрезвычайно важным нюансом является то, что агент должен обладать некоторой информацией о своем текущем состоянии, в том числе и о своем текущем положении в пространстве. Будем достаточно неестественно, если информацию о координате должен будет отслеживать разработчик конечного агента, т.к. во всех остальных ситуациях система берет на себя всю работу по манипуляциям с пространством. Фактически, если мы переложим ответственность за отслеживание положения агента на пользователя библиотеки поддержки, то мы нарушим инкапсуляцию (\cite{GoF}) системы и создадим почву для возникновения ошибок.

Следовательно, информацию о текущей координате агента должна отслеживать и передавать агенту система поддержки. Способов пододбной передачи несколько: через аргументы метода и через поля{\slash}свойства. Передача через аргументы кажется более естественной с точки зрения архитектуры приложения, однако, после экспериментов над прототипом системы стало понятно, что подобный подход достаточно неудобен. Дело в том, что чаще всего сосотояние агента хранится в его полях и используется при вычислениях из различных private методов. В результате все переданные из системы в агента данные о его положении либо немедленно складываются в поля, либо начинают обрабатыватся совершенно иным способом, нежели остальная информаци о состоянии. Чтобы избегать подобных неестетсвенностей было принято решение передавать информацию о координате через поля агента.




\section{Размещения агентов на карте}\label{sec:map+cells}
Размещение агентов --- это одна из ролей, которую выполняет карта в терминах модели АКР. Как уже было сказано в разделе \ref{sec:spaceArch}, каждой такой роли в реализации системы отводится отдельная сущность. Для карты, как контейнера агентов, таковой програмной сущностью является карта (в дальнейшем, чтобы различать <<карту>> ы терминах модели АКР, от <<карты>> в програмной модели, будем называть первую <<пространством>>). Карта хранит ячейки, которые являются програмными моделями точек пространства в смысле контейнера для размещения агентов.

Приведем интерфейс ячейки карты:

\begin{cscode}
public interface ICell<TCoordinate, TNodeData, TEdgeData>:
        IEnumerable<IAnt<TCoordinate, TNodeData, TEdgeData>>
    where TCoordinate: ICoordinate<TCoordinate>
{
    IMap<TCoordinate, TNodeData, TEdgeData> Map { get; }
    TCoordinate Coordinate { get; }
}
\end{cscode}

Он довлольно естественный: ячейка умеет перечислять находящихся в ней агентов и знает то, в какой точке какой карты она расположена.

Интерфейс карты представляет больший интерес:

\begin{cscode}
public interface IMap<TCoordinate, TNodeData, TEdgeData>:
        ISparsedMapping<TCoordinate, ICell<TCoordinate, TNodeData, TEdgeData>>
    where TCoordinate: ICoordinate<TCoordinate>
{
    Topology<TCoordinate> Topology { get; }
}

public interface ISparsedMapping<TKey, TValue>:
        IEnumerable<KeyValuePair<TKey, TValue>>
{
    bool TryGet(TKey key, out TValue value);
}
\end{cscode}

Легко заметить, что одно из основных свойств интерфейса --- обеспечение разреженного хранения ячеек. Почему именно разреженного? Очевидно, что не имеет смысла держать в памяти представления тех ячеек, в которых на данный момент отсутствуют агенты. Тем не менее, в интерфейсе \verb!IDataLayer!, который, как кажется естественным, должен быть аналогичен \verb!IMap!, используется прямо противоположный подход --- в нем (с точки зрения потребителя) одновременно храняться данные \textit{всех} точек пространства.

Изначально поведения \verb!IMap! и \verb!IDataLayer! были аналогичными, однако после проведения экспериментов над прототипом системы стало понятно, что не смотря на общую схожетсть функциональности этих двух компонентов, сценарии их использования существенно отличаются.

Для \verb!IDataLayer! справедливо утверждение, что если в определенную точку пространства данные ни разу не записывались, то при чтении из нее мы получим некоторое значение по умолчанию, которое естественным образом будет использоватся в наших алгоритмах. Например, в расчетах нового значения данных, нам нужно знать старое, тогда удобно считать, что если старого значения не было, то оно равно значению по умолчанию --- 0. Соответственно, для потребителя интерфейса было бы удобно никогда не думать про случай <<отсутствующего значения>>, а работать с \verb!IDataLayer!, как со всюду-определенным отображением.

Более того, подобный интерфейс можно легко реализовать без дополнительных накладных расходов. Поскольку данные ячеек на практике почти всегда представляются неизменяемыми структурами (существенно реже --- неизменяемыми объектами; использование изменяемых типов данных в качестве представления данных ячеек имеет очень ограниченную область применимости), следовательно нет необходимости хранить значение по умолчанию для каждой точки (более того, на картах с бесконечным колличеством точек пришлось бы хранить бесконечное множество экзепляров этого значения), можно просто сконструировать его один раз и при запросах возвращать эакешированое значение \cite{Memoisation}.

Для \verb!IMap! подобная техника не эффективна, поскольку содержимое карты --- это ячейки, которые представляют ценность только как контейнер для агентов. Соответственно, код исполльзующий карту, обычно посроен следующим образом:

\begin{algorithmic}
    \ForAll{$i \in \{\, v \mid v \in V, \exists (\mathrm{current}, v) \in E \,\}$}
        \ForAll{$ agent \in \mathrm{Agents}(i)$}
            \State do something with $agent$
        \EndFor
    \EndFor
\end{algorithmic}

Очевидно, что в рамках такого кода возвращение <<ячейки по умолчанию>> бессмысленно и неэффективно. В связи с этим, в системе для \verb!IMap! был выбран противоположный к \verb!IDataLayer! подход: возвращать только ячейки реально содержащие данные, причем даже если в карте хранится пустая ячейка, то она никогда не будет возвращена на запрос \lstinline!map.TryGet(ccordinate, out cell)! и на \lstinline!map.GetEnumerator()!.













