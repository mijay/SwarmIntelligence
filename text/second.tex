\chapter{Практическая реализация}\label{sec:second}
\section{Спецификация поддерживаемых АКР}
Поскольку, как было сказано в разделе (\ref{sec:akrprop}), существует большое количество подклассов и разновидностей АКР, то первой задачей при разработке системы их поддержки становится задача фиксации требований к ней --- разработка спецификации поддерживаемого типа АКР.

Необходима была такая формулировка АКР, которая обладает следующими свойствами: наибольшей общностью, хорошей приспособленностью для использования большинства известных алгоритмов (в т.ч. наиболее популярных --- в первую очередь, алгоритма муравейника \cite{AntAlg}), высокой выразительностью для прикладных задач, близостью к формулировкам многоагентных систем. Кроме того, эта формулировка должна быть легко выразима в терминах ОО \nomenclature{ОО}{Объектно Ориентированный}\cite{ObjectOriented} архитектуры и удобна для программной реализации.

В связи с последними двумя требованиями, а также в связи с естественным для всех спецификаций ПО \nomenclature{ПО}{Программное Обеспечение}
 требованием максимальной полноты и формальности, конечная формулировка получилась иерархичной и объемной. Приведем её последовательно, начиная от общих понятий.

АКР --- это изменяющаяся во времени система, обладающая следующими свойствами:
\begin{enumerate}
    \item Система функционирует в некотором адресуемом пространстве (карте) с координатами.
    \item Каждой точке этого пространства (ячейке) соответствует некоторый набор данных (фон ячейки).
    \item Кроме того, в ячейках могут располагаться объекты карты (агенты). Количество агентов в ячейке не ограниченно. Каждый агент располагается в некоторой ячейке, и притом только в одной.
    \item Система изменяется итеративно. Все итерации равнозначны. Одна итерация называется ходом.
\end{enumerate}

На карту и координаты накладываются следующие требования:
\begin{enumerate}[resume]
	\item Карта является, фактически, сюръективной не всюду определенной \linebreak функцией отображающей пространство координат в множество ячеек.
 $$Map\!: Coord \to Cell$$
	\item Будем называть координаты, для которых функция карты определена (т.е. те координаты, которым соответствует ячейка карты), достижимыми.
$$Reach \subseteq Coord\!: \forall c \in Reach\: \exists Map(c)$$
    \item \label{agentprop:cube} Для каждой пары координат определен куб ими задаваемый --- некоторая последовательность координат, про которые мы можем неформально сказать, что <<они лежат в n-мерном кубе, верхний левый и нижний правый угол которого заданы исходной парой координат>>. Причем эта пара координат входит в свой собственный куб.
$$Cube\!: Coord \times Coord \to 2^{Coord};\: \forall a,b \in Coord\!: a,b \in Cube(a,b)$$
    \item \label{agentprop:cubeReach} Для каждой пары координат верно, что если они достижимы, то и все координаты входящие в куб ими заданный также достижимы.
$$\forall a,b \in Reach\!: \forall c \in Cube(a,b) \: c \in Reach$$
    \item \label{agentprop:suburb} Для каждой достижимой координаты и неотрицательного числа определено непустое множество координат, называемых окрестностью данной координаты с данным радиусом. Причем каждая достижимая координата лежит в любой своей окрестности.
$$Suburb\!: Reach \times \mathbb{R}_+ \to 2^{Reach};\: \forall c \in Reach, \forall r \in \mathbb{R}_+\!: c \in Suburb(c,r)$$
	\item В дальнейшем мы будем рассматривать только достижимые координаты, если иное не отмечено особо.
\end{enumerate}

Фон ячейки можно рассматривать либо как неотъемлемое свойство самих ячеек, либо как некоторое множество (фон карты) биективно отображаемое на множество ячеек. Определение очевидно эквивалентны. При описании формулировки будет удобнее пользоваться первым, однако при описании модели программной реализации --- вторым. Данные хранимые в фоне ячеек в общем определении АКР не специфицируются и зависят от конкретного алгоритма.

Агент --- это единственная активная сущность в системе АКР. На каждом ходе он выполняет некоторый набор действий, изменяющих его и всю систему в целом. Эти действия определяются заложенным в агента алгоритмом на основе его состояния и состояния всей системы. Для агента могут быть постулированы следующие свойства:
\begin{enumerate}[resume]
    \item Агент расположен в некоторой ячейке, т.е. для него определена координата.
    \item Агент на каждом ходе обладает неизменной характеристикой --- радиусом его области видимости, являющейся неотрицательным числом.
    \item Агент в течении хода имеет доступ ко всем ячейкам, координаты которых входят в окрестность его координаты с радиусом, равным радиусу области его видимости. Очевидно, что ячейка, в которой расположен агент, входит в эту окрестность.
    \item Под доступом к ячейке подразумевается:
    \begin{enumerate}
        \item чтение ее координаты,
        \item доступ к данным ее фона на чтение и запись,
        \item перечисление всех агентов в ней расположенных,
        \item отправка сообщения любому из этих агентов,
        \item добавление в нее нового агента,
        \item перемещение самого себя в эту ячейку.
    \end{enumerate}
    \item\label{agentprop:msg} Агент может принимать сообщения (то есть иметь доступ на чтение к их содержимому), которые отправили ему другие агенты. Сообщения являются однонаправленными, не несущими информации об отправителе, локальными во времени (сообщения отправленные в течении хода будут получены в начале следующего, а затем более не будут доступны). Содержимое сообщений зависит от конкретных алгоритмов и не специфицируется.
    \item\label{agentprop:broadcast} Агент может отправлять широковещательные сообщения. Подобные сообщения будут получены всеми агентами в начале следующего хода, включая тех агентов, которые будут созданы в течении текущего хода, а также включая отправителя.
    \item Агент может удалить себя с карты: перестать быть расположенным в некоторой ее ячейке и перестать получать широковещательные сообщения. Такой агент более не может изменять состояние системы и самого себя.
    \item\label{agentprop:indep} Действия агента на каждом ходе не зависят от действия других агентов в том-же ходе: все сообщения, изменения фона карты, добавление/перемещение/удаление агентов --- результаты всех действий других агентов не будут доступны ему. Фактически, если мы определим текущее состояние системы, как функцию от времени (роль времени играет номер текущего хода), тогда каждый агент будет по текущему значению этой функции строить ее преобразование, а значение функции в следующий момент времени будет результатом применения композиции всех таких преобразований.
    \item\label{agentprop:invar} Более того, действия всех агентов (в терминах преобразования системы) инвариантны относительно порядка приминения. То есть система будет преведена в одно и тоже состояние в независимости от того, в каком порядке будут применены эти преобразования. Причем очевидно, что не обязательно груперовать все действия одного агента в течении хода в одно преобразование, а можно представлять каждое действие отдельным.
\end{enumerate}

Мы закончили формулировку выбранной мной вариации АКР. Очевидно, что работа любого из алгоритмов обладающих свойствами, описанными в разделе (\ref{sec:akrprop}), может быть эмулированна им.

Система поддержки АКР должна брать на себя все сервистные функции алгоритма с вышеописанными свойствами, оставляя разработчику конечного алгоритма лишь работу по реализации логики агентов, спецификации типов данных сообщений и фона карты, а также описнаия координат карты. Причем, очевидно, что для такого разработчика наибольший интерес будет представлять создание агента, поэтому все остальные задачи нужно максимально упростить.

\section{Пояснения и уточнения свойств}
Перед тем как переходить к следующим вопросам, уточним причины использования подобных формулировок некоторых свойств.

Свойство (\ref{agentprop:suburb}) необходимо для поддержки МАА системой. Стоит отметить особо, что система ориентирована в первую очередь именно на них, поскольку МАА алгоритмов изветсно больше чем просто АКР, а также поскольку все неалгоритмические приложения системы используют многоагентный подход.

Свойства (\ref{agentprop:cube}) и (\ref{agentprop:cubeReach}) черезвычайно удобны для введения возможности разбиения карты на некоторое колличество непересекающихся частей, которая необходима для оптимальной организации распределения вычислений в системе поддержки АКР. Поскольку эти свойства дровольно естественны и легко реализуемы, то их было решено ввести в общую модель.

Свойства (\ref{agentprop:indep}) и (\ref{agentprop:invar}) агента являются одними из наиболее важных. Фактически они представляют собой другую формулировку свойства (\ref{akrprop:indep}) АКР (стр. \pageref{akrprop:indep}) и являются существенными с точки зрения реализации, поскольку создают идеальные условия для распараллеливания и распределения вычислений действий агентов и их приминения на каждом ходе.

Из-за наличия этих свойств становится невозможным введение операций удаления или перемщения одного агента другим (эти операции были бы довольно полезны в некоторых многоагентных системах). А также невозможно непосредственное взаимодействие агентов, то есть, если возвращаться к терминам програмной модели, вызов методов одного агента другим, что и привело к необходимости введения понятия сообщений и операций их отправки и получения.

Теоретически возможно организовать работу АКР и без обмена сообщениями. В этом случае, взаимодействие агентов будет основано на передаче информации через фон карты. То есть для того, чтобы агент $A$ передал некоторую информацию агенту $B$ необходимо, чтобы агент $A$ записал ее в фон клетки, в которой находится агент $B$. Однако, очевидно, что такой подход содержит <<подводные камни>>: если агент $B$ переместился в другую ячейку на том же ходе, когда агент $A$ передал ему информацию, то он ее не получит; если агенты $A$ и $C$ передали информацию агенту $B$ таким способом одновременно, то одна информация перекроет другую и возникнет ситуация <<потерянной записи>>\todo{find ref}.

Вышеописанная техника применялась в прототипе существующей системы\todo{ссылки на мои прошлые работы? чтото сказать?}, в котором не требовалось выполнение свойства (\ref{agentprop:invar}). Она показала себя как черезвычайно неудобная для реализации и использования. В том-же прототипе вместо широковещательных сообщений (свойство (\ref{agentprop:broadcast})) использовались глобальные переменные, которые не смотря на то, что нарушают свойство (\ref{agentprop:invar}), являются более удобными для использования.

Свойство (\ref{agentprop:msg}) требует, чтобы отправленные в текущем ходе сообщения были приняты лишь в следующем. Это требование является следствием свойства (\ref{agentprop:indep}), однако оно крайне неудобно с практической точки зрения. Как показала практика работы с прототипом системы и анализ возможных сценариев ее приминения, чаще всего сообщения отправленные в текущем ходе содержат данные актуальные именно в нем. 

Поскольку, чтобы на момент получения сообщения было возможно восстановить контекст его отправки и правильно его интерпретировать, приходится сохранять довольно много информации в состоянии агента, то почти постоянно при разработке агента тратиться множество времени на эти вспомогательные операции, которые, теоретически, должна целиком брать на себя система поддержки. В худших, но нередких, случаях приходится даже разделять логически цельный ход на два хода системы: в первом производится отправка сообщений, а во втором --- некоторые действия зависящие от сообщений. Очевидно, что необходимо обоих ситуаций избегать.

В связи с вышеуказанными проблемами в системе использовался несколько видоизменнный ход, разбитый на две стадии: начальная и конечная. В начальной стадии хода агент может посылать сообщения и читать сообщения, принятые в предыдущем ходе. В конечной стадии агент не может отсылать сообщения, но может принимать сообщения, посланные на начальной стадии. В остальном стадии равноправны. Подобное разделение позволяет агентам сделать последовательные ходы максимально независимыми друг от друга и существенно сократить количество информации хранимой в их состоянии (в лучшем случае --- избавиться от хранимого состояния полностью). Агенты, для которых <<актуальность>> сообщений не критична, могут реализовывать только начальную стадию хода.

Для улучшения удобства работы с широковещательными сообщениями были введены несколько средств: именнованые сообщения, постоянные сообщения и обработчики сообщений. \todo{используй IObservable+linq в коде}

Именнование сообщений означает, что каждому широковещательному сообщению будет присвоенно имя (по умолчанию --- пустое), и агенты смогут фильтровать сообщения по этому имени.

Постоянные сообщения --- это широковещательные сообщения, которые будут доступны для чтения во всех последующих ходах, а не только в одном. 

Обработчики сообщений --- это некоторые функции, которые могут модифицировать список широковещательных сообщений с определенным именем, например оставлять в нем только сообщение с самыми большими значениями или заменять все сообщения одним, содержащим сумму их данных.

Сочетание двух последних техник позволяет эмулировать глобальные переменные не нарушающие свойства (\ref{agentprop:invar}).

\section{Требования к реализации}
Поскольку планируется будующее использование системы поддержки \linebreak АКР в работе лаборатории РВИиМАП\todo{на чтото сослаться?}, в том числе в рамках мроводимого моим научным руководителем спецкурса Нейронные Сети, то к ее реализации были предьявленны некоторые дополнительные требования. Во-первых, система должна быть написанна на языке C\# и работать на платформе .NET, поскольку остальные разработки лабборатории выполняются с помощью этих технологий. Во-вторых, было необходимо достичь максимальной простоты решения задач, следовательно, система поддержки должна иметь средства облегчающие решения типовых задач <<из коробки>>. В идеале небольшие задачи-примеры должны занимать всего несколько строк, причем легко-читаемых и понятных. В-третьих, система должна иметь документацию, а ее код должен быть прокомментирован. В-четвертых, система должна быть легко расширяема и модифицируема и, при этом, показывать неплохую производительность.

Систему было решено писать на C\# 4.0 под фреймворк .NET 4.0 \cite{DotNet4}. Выбор столь новых инструментов обусловлен тем, что в фреймворке 4.0 существует большое количество механизмов для удобной работы с рсапараллеливанием \cite{PLINQ}, а также с асинхронными вычислениями \cite{IObservable}, которые неизбежно возникнут при реализации распределения вычислений. Также .NET 4.0 содержит набор библиотек WCF \cite{WCF}, с помощью которых можно легко организовать обмен сообщениями между вычислительными узлами, необходимый для распределения вычислений (подобное решение является временным и будет использоватся лишь на начальном этапе).

Также среди инструментов стоит отметить особо библиотеку Code Contracts \cite{CodeContracts} для .NET 4.0, реализующую идеалогию контрактного программирования \cite{Contracts}.

При реализации необходимо учитывать следующие моменты:
\begin{enumerate}
    \item Размер карты может быть очень большим. Поэтому хранение каких-либо сервистных структур данных для каждой ячейки невозможно.
    \item Имеет смысл хранить сервистные структуры данные лишь для ячеек, в которых расположен хотябы один агент.
    \item Организация данных фона карты существенно зависит от специфики этих данных. Поэтому фон карты воспринимается как отдельный объект, используемый для получения данных каждой конкретной ячейки.
    \item При перемещении агентов из одних ячеек в другие возникает необходимость удалять ячейки, в которых нет больше агентов, и добавлять ячейки, в которые агенты переместились. Поскольку вышеописанные операции происходят многократно в течении каждого хода, а операции с выделением/освобождением памяти в .NET довольно медленные, то необходимо минимизировать их количество, что возможно сделать с помощью реализации пула сервистных объектов ячеек \cite{ObjPool}.
    \item В ходе работы системы будет черезвычайно активно вестись работа с координатами. Поэтому координаты необходимо реализовать как структуры (т.к. операции с ними несколько быстрее) реализующие некоторый интерфейс. Кроме того, использовать координаты надо не как этот интерфейс, поскольку подобное использование приведет к боксингу структур в объекты с существенной потерей производительности, а как генрик-тип реализующий интерфейс.
    \item Вызов виртуального метода занимает больше времени, чем вызов обычного. Таким образом надо максимально отказатся от их использования. \    \textit{Однако при использовании абстрактных методов вышеуказанного падения производительности не наблюдается.}
    \item Работа со свойствами медленнее, чем с полями. Наличие блоков try-catch также существенно снижает производитеьность. Вызов делегата работает быстрее вызова виртуаьлного метода. Стандартные field-like события неэффективно реализуют операции добавления и удаления делегата --- эффективнее использовать вместо них List<T>. Все методы синхронизации работают очень медленно.
    \item Существуют способы избегания проблем производительности, описанных в предыдущем пункте, однако эти способы приводят к нетривиальным решениям, которыми сложно пользоватся и сопровождать. Поэтому нужно сохранять баланс между производительностью кода и его качеством.
\end{enumerate}

При проектирвоании системы, для достижения ее расширяемости и модифицируемости, было решено следовать набору принципов SOLID \cite{SOLID}. И в первую очередь --- принципу SRP (Single Responsibility Principle --- англ., принцип единственной обязанности), согластно которому каджый объект должен выполнять только одну задачу \cite{SRP}. Благодаря использованию SRP удается создать систему, каждый из аспектов поведения которой можно расширять или модифицировать заменяя одни ее компоненты аналогами. К сожалению, принципы SRP и ISP \cite{ISP} из набора SOLID не применимиы к некоторым объектам в системе, поскольку эти объекты исполняют роль тех или иных сущностей в АКР и потому их интерфейсы логически неделимы.

Использование SOLID приводит к созданию многокомпонентных програмных модулей, причем <<сборка>> из этих компонент работоспособной системы зачастую является трудоемкой задачей \cite{SmthAboutIt}. Часто для облегчения этой задачи используются т.н. DI-контейнеры \cite{DI}, однако на начальном этапе от их использования в проекте решено отказатся --- добавление зависимости от большой библиотеки при том, что выгода от ее использования не столь очевидна, было призванно нецелесообразным. Но ни что не мешает конечным пользователям библиотеки использовать их.

\section{Описание интерфейсов координат}
Начнем описание програмной модели с описания наиболее базовой ее части --- интерфейсов определеяющих координаты. Как уже было сказанно выше реализациями этих интерфейсов должны быть структуры, причем используемые как генрик-параметры.

Сущность кооррдинаты была разбита на две: собственно координаты и <<измеритель>> -- вспомогательная сущность, через которую реализуется свойство (\ref{agentprop:suburb}) координат. Подобное разбиение необходимо, поскольку результат операции <<взятия окрестности>> зависит от топологии текущей карты, а значит и сущность реализующая эту операцию должна использовать данные о карте и иногда реализовывать нетривиальную логику. Добавление ссылки на карту в координату нарушает логическую иерархию зависимостей объектов, а добавление логики --- принцип SRP.

Таким образом интерфейс координат будет следующим:

\singlespacing
\begin{lstlisting}
public interface ICoordinate<C>: ICloneable, IEquatable<C>
    where C: struct, ICoordinate<C>
{
    // Вспомогательный метод:
    C Cast { get; }
    // Строит куб координат, где this --- нижняя граница:
    IEnumerable<C> Range(C upperBound);
    // Проверяет, лежит ли текущая координата в кубе заданном аргументами:
    bool IsInRange(C lowerBound, C upperBound);
}
\end{lstlisting}
\onehalfspacing

Особый интерес в нем вызывает описание генерик-параметра C.