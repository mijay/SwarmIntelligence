\chapter{Практическая реализация}\label{sec:second}
\section{Спецификация поддерживаемых АКР}
Поскольку, как было сказано в разделе (\ref{sec:akrprop}), существует большое количество подклассов и разновидностей АКР, то первой задачей при разработке системы их поддержки становится задача фиксации требований к ней --- разработка спецификации поддерживаемого типа АКР.

Необходима была такая формулировка АКР, которая обладает следующими свойствами: наибольшей общностью, хорошей приспособленностью для использования большинства известных алгоритмов (в т.ч. наиболее популярных --- в первую очередь, алгоритма муравейника \cite{AntAlg}), высокой выразительностью для прикладных задач, близостью к формулировкам многоагентных систем. Кроме того, эта формулировка должна быть легко выразима в терминах ОО \nomenclature{ОО}{Объектно Ориентированный}\cite{ObjectOriented} архитектуры и удобна для программной реализации.

В связи с последними двумя требованиями, а также в связи с естественным для всех спецификаций ПО \nomenclature{ПО}{Программное Обеспечение}
 требованием максимальной полноты и формальности, конечная формулировка получилась иерархичной и объемной. Приведем её последовательно, начиная от общих понятий.

АКР --- это изменяющаяся во времени система, обладающая следующими свойствами:
\begin{enumerate}
    \item Система функционирует в некотором адресуемом дискретном пространстве (карте) с координатами.
    \item Каждой точке этого пространства (ячейке) соответствует некоторый набор данных (фон ячейки).
    \item Кроме того, в ячейках могут располагаться объекты карты (агенты). Количество агентов в ячейке не ограниченно. Каждый агент располагается в некоторой ячейке, и притом только в одной.
    \item Система изменяется итеративно. Все итерации равнозначны. Одна итерация называется ходом.
\end{enumerate}

На карту и координаты накладываются следующие требования:
\begin{enumerate}[resume]
	\item Карта является, фактически, сюръективной не всюду определенной \linebreak функцией, отображающей пространство координат в множество ячеек.
 $$Map\!: Coord \to Cell$$
	\item Будем называть координаты, для которых функция карты определена (т.е. те координаты, которым соответствует ячейка карты), достижимыми.
$$Reach \subseteq Coord\!: \forall c \in Reach\: \exists Map(c)$$
    \item \label{agentprop:cube} Для каждой пары координат определен куб, ими задаваемый --- некоторая последовательность координат, про которые мы можем неформально сказать, что <<они лежат в n-мерном кубе, верхний левый и нижний правый угол которого заданы исходной парой координат>>. Причем эта пара координат входит в свой собственный куб.
$$Cube\!: Coord \times Coord \to 2^{Coord};\: \forall a,b \in Coord\!: a,b \in Cube(a,b)$$
    \item \label{agentprop:cubeReach} Для каждой пары координат верно, что если они достижимы, то и все координаты входящие в куб, ими заданный, также достижимы.
$$\forall a,b \in Reach\!: \forall c \in Cube(a,b) \: c \in Reach$$
    \item \label{agentprop:mapSplit} Карта может быть разбита на несколько кубов, заданных некоторыми достижимыми координатами.
$$\exists a_1,\cdots,a_n,b_1,\cdots,b_n \in Reach: \: Reach = \biguplus_{i=1}^n Cube(a_i,b_i) $$
    \item \label{agentprop:suburb} Для каждой достижимой координаты и неотрицательного числа определено непустое множество координат, называемых окрестностью данной координаты с данным радиусом. Причем каждая достижимая координата лежит в любой своей окрестности.
$$Suburb\!: Reach \times \mathbb{R}_+ \to 2^{Reach};\: \forall c \in Reach, \forall r \in \mathbb{R}_+\!: c \in Suburb(c,r)$$
	\item В дальнейшем мы будем рассматривать только достижимые координаты, если иное не отмечено особо.
\end{enumerate}

Фон ячейки можно рассматривать либо как неотъемлемое свойство самих ячеек, либо как некоторое множество (фон карты), биективно отображаемое на множество ячеек. Определения очевидно эквивалентны. При описании формулировки будет удобнее пользоваться первым, однако при описании модели программной реализации --- вторым. Данные, хранимые в фоне ячеек, в общем определении АКР не специфицируются и зависят от конкретного алгоритма.

Агент --- это единственная активная сущность в системе АКР. На каждом ходе он выполняет некоторый набор действий, изменяющих его и всю систему в целом. Эти действия определяются заложенным в агента алгоритмом на основе его состояния и состояния всей системы. Для агента могут быть постулированы следующие свойства:
\begin{enumerate}[resume]
    \item Агент расположен в некоторой ячейке, т.е. для него определена координата.
    \item Агент на каждом ходе обладает неизменной характеристикой --- радиусом его области видимости, являющейся неотрицательным числом.
    \item \label{agentprop:locale} Агент в течении хода имеет доступ ко всем ячейкам, координаты которых входят в окрестность его координаты с радиусом, равным радиусу области его видимости. Очевидно, что ячейка, в которой расположен агент, входит в эту окрестность.
    \item \label{agentprop:access} Под доступом к ячейке подразумевается:
    \begin{enumerate}
        \item чтение ее координаты,
        \item доступ к данным ее фона на чтение и запись,
        \item перечисление всех агентов в ней расположенных,
        \item отправка сообщения любому из этих агентов,
        \item добавление в нее нового агента,
        \item перемещение самого себя в эту ячейку (при этой операции доступная агенту окрестность не изменяется).
    \end{enumerate}
    \item\label{agentprop:msg} Агент может принимать сообщения (то есть иметь доступ на чтение к их содержимому), которые отправили ему другие агенты. Сообщения являются однонаправленными, не несущими информации об отправителе, локальными во времени (сообщения, отправленные в течении хода, будут получены в начале следующего, а затем более не будут доступны). Содержимое сообщений зависит от конкретных алгоритмов и не специфицируется.
    \item\label{agentprop:broadcast} Агент может отправлять широковещательные сообщения. Подобные сообщения будут получены всеми агентами в начале следующего хода, включая тех агентов, которые будут созданы в течении текущего хода, а также включая отправителя.
    \item Агент может удалить себя с карты: перестать быть расположенным в некоторой ее ячейке и перестать получать широковещательные сообщения. Такой агент более не может изменять состояние системы и самого себя.
    \item\label{agentprop:indep} Действия агента на каждом ходе не зависят от действия других агентов в том же ходе: все сообщения, изменения фона карты, добавление/перемещение/удаление агентов --- результаты всех действий других агентов не будут доступны ему. Фактически, если мы определим текущее состояние системы, как функцию от времени (роль времени играет номер текущего хода), тогда каждый агент будет по текущему значению этой функции строить ее преобразование, а значение функции в следующий момент времени будет результатом применения композиции всех таких преобразований.
    \item\label{agentprop:invar} Более того, действия всех агентов (в терминах преобразования системы) инвариантны относительно порядка применения. То есть система будет приведена в одно и тоже состояние в независимости от того, в каком порядке будут применены эти преобразования. Причем, очевидно, что не обязательно группировать все действия одного агента в течении хода в одно преобразование, а можно представлять каждое действие отдельным.
\end{enumerate}

Мы закончили формулировку выбранной вариации АКР. Очевидно, что работа любого из алгоритмов, обладающих свойствами, описанными в разделе (\ref{sec:akrprop}), может быть эмулирована ими.

Система поддержки АКР должна брать на себя все сервисные функции алгоритма с вышеописанными свойствами, оставляя разработчику конечного алгоритма лишь работу по реализации логики агентов, спецификации типов данных сообщений и фона карты, а также описания координат карты. Причем, очевидно, что для такого разработчика наибольший интерес будет представлять создание агента, поэтому все остальные задачи нужно максимально упростить.

\section{Пояснения и уточнения свойств}
Перед тем как переходить к следующим вопросам, уточним причины использования подобных формулировок некоторых свойств.

Свойство (\ref{agentprop:suburb}) необходимо для поддержки МАА системой. Стоит отметить особо, что система ориентирована в первую очередь именно на них, поскольку МАА алгоритмов известно больше, чем просто АКР, а также поскольку все неалгоритмические приложения системы используют многоагентный подход.

Свойства (\ref{agentprop:cube}), (\ref{agentprop:cubeReach}) и (\ref{agentprop:mapSplit}) чрезвычайно удобны для введения возможности разбиения карты на некоторое количество непересекающихся частей, которая необходима для оптимальной организации распределения вычислений в системе поддержки АКР. Поскольку эти свойства довольно естественны и легко реализуемы, то их было решено ввести в общую модель.

Свойства (\ref{agentprop:indep}) и (\ref{agentprop:invar}) агента являются одними из наиболее важных. Фактически, они представляют собой другую формулировку свойства (\ref{akrprop:indep}) АКР (стр. \pageref{akrprop:indep}) и являются существенными с точки зрения реализации, поскольку создают идеальные условия для распараллеливания и распределения вычислений действий агентов и их применения на каждом ходе.

Из-за наличия этих свойств становится невозможным введение операций удаления или перемещения одного агента другим (эти операции были бы довольно полезны в некоторых многоагентных системах). А также невозможно непосредственное взаимодействие агентов, то есть, если возвращаться к терминам программной модели, вызов методов одного агента другим, что и привело к необходимости введения понятия сообщений и операций их отправки и получения.

Теоретически возможно организовать работу АКР и без обмена сообщениями. В этом случае, взаимодействие агентов будет основано на передаче информации через фон карты. То есть, для того, чтобы агент $A$ передал некоторую информацию агенту $B$ необходимо, чтобы агент $A$ записал ее в фон ячейки, в которой находится агент $B$. Однако, очевидно, что такой подход содержит <<подводные камни>>: если агент $B$ переместился в другую ячейку на том же ходе, когда агент $A$ передал ему информацию, то он ее не получит; если агенты $A$ и $C$ передали информацию агенту $B$ таким способом одновременно, то одна информация перекроет другую и возникнет ситуация <<потерянной записи>> \cite{DBBook}.

Вышеописанная техника применялась в прототипе существующей системы \cite{Me1,Me2}, в котором не требовалось выполнение свойства (\ref{agentprop:invar}). Она показала себя как чрезвычайно неудобная для реализации и использования. В том же прототипе вместо широковещательных сообщений (свойство (\ref{agentprop:broadcast})) использовались глобальные переменные, которые не смотря на то, что нарушают свойство (\ref{agentprop:invar}), являются более удобными для использования.

Свойство (\ref{agentprop:msg}) требует, чтобы отправленные в текущем ходе сообщения были приняты лишь в следующем. Это требование является следствием свойства (\ref{agentprop:indep}), однако оно крайне неудобно с практической точки зрения. Как показала практика работы с прототипом системы и анализ возможных сценариев ее применения, чаще всего сообщения отправленные в текущем ходе содержат данные, актуальные именно в нем. 

Поскольку, чтобы на момент получения сообщения было возможно восстановить контекст его отправки и правильно его интерпретировать, приходится сохранять довольно много информации в состоянии агента, то почти постоянно при разработке агента тратится множество времени на подобные вспомогательные операции, которые, теоретически, должна целиком брать на себя система поддержки. В худших, но нередких, случаях приходится даже разделять логически цельный ход на два хода системы: в первом производится отправка сообщений, а во втором --- некоторые действия, зависящие от сообщений. Очевидно, что необходимо обеих ситуаций избегать.

В связи с вышеуказанными проблемами, в системе использовался несколько видоизмененный ход, разбитый на две стадии: начальная и конечная. В начальной стадии хода агент может посылать сообщения и читать сообщения, принятые в предыдущем ходе. В конечной стадии агент не может отсылать сообщения, но может принимать сообщения, посланные на начальной стадии. В остальном стадии равноправны. Подобное разделение позволяет агентам сделать последовательные ходы максимально независимыми друг от друга и существенно сократить количество информации хранимой в их состоянии (в лучшем случае --- избавиться от хранимого состояния полностью). Агенты, для которых <<актуальность>> сообщений не критична, могут реализовывать только начальную стадию хода.

Для улучшения удобства работы с широковещательными сообщениями были введены несколько средств: именованные сообщения, постоянные сообщения и обработчики сообщений.

Именование сообщений означает, что каждому широковещательному сообщению будет присвоено имя (по умолчанию --- пустое), и агенты смогут фильтровать сообщения по этому имени.

Постоянные сообщения --- это широковещательные сообщения, которые будут доступны для чтения во всех последующих ходах, а не только в одном. 

Обработчики сообщений --- это некоторые функции, которые могут модифицировать список широковещательных сообщений с определенным именем, например оставлять в нем только сообщение с самыми большими значениями или заменять все сообщения одним, содержащим сумму их данных.

Сочетание двух последних техник позволяет эмулировать глобальные переменные, не нарушающие свойства (\ref{agentprop:invar}).

Свойство (\ref{agentprop:locale}) требует, чтобы агент имел доступ только к ячейкам своей окрестности. Практика использования прототипа системы и анализ возможных сценариев применения ее самой показали, что практически во всех случаях агенты в каждый конкретный момент времени работают в окрестностях, имеющих одну и ту же топологию. Причем, автор агента еще на этапе разработки может легко ее спрогнозировать. Однако использовать этот прогноз непросто, поскольку каждый раз одинаковая топология выражается через различный набор координат, т.к. агент движется и следовательно движется центр его окрестности.

Чтобы повысить прогнозируемость окружения агента на каждом ходе и, следовательно, простоту формулирования алгоритма для него, вводится понятие локальных координат. Локальные координаты для агента --- это координаты, аналогичные глобальным, полученные из них некоторым обратимым преобразованием, переводящим точку в которой расположен агент в начало координат. Цель этого преобразования --- представить окрестности с одинаковыми топологиями одинаковыми координатами. Причем с практической точки зрения само преобразование может быть скрыто в объектах, реализующих получение окрестности агента, но обратное преобразование обязательно должно быть представлено во внешних интерфейсах.

\section{Требования к реализации}\label{sec:request}
Поскольку планируется будущее использование системы поддержки АКР в работе лаборатории РВИиМАП, в том числе в рамках  спецкурса Нейронные Сети, то к ее реализации были предъявлены некоторые дополнительные требования. Во-первых, система должна быть написана на языке C\# и работать на платформе .NET, поскольку остальные разработки лаборатории выполняются с помощью этих технологий. Во-вторых, было необходимо достичь максимальной простоты решения задач, следовательно, система поддержки должна иметь средства, облегчающие решения типовых задач. В идеале небольшие задачи-примеры должны занимать всего несколько строк, причем легко читаемых и понятных. В-третьих, система должна иметь документацию, а ее код должен быть прокомментирован. В-четвертых, система должна быть легко расширяемой и модифицируемой и, при этом, показывать неплохую производительность.

Систему было решено писать на C\# 4.0 под фреймворк .NET 4.0 \cite{DotNet4}. Выбор столь новых инструментов обусловлен тем, что в фреймворке 4.0 существует большое количество механизмов для удобной работы с распараллеливанием \cite{Parallel}, а также с асинхронными вычислениями \cite{ASP}, которые неизбежно возникнут при реализации распределения вычислений. Также .NET 4.0 содержит набор библиотек WCF \cite{WCF}, с помощью которых можно легко организовать обмен сообщениями между вычислительными узлами, необходимый для распределения вычислений (подобное решение является временным и будет использоваться лишь на начальном этапе).

Также среди инструментов стоит отметить особо библиотеку Code Contracts \cite{CodeContracts} для .NET 4.0, реализующую идеологию контрактного программирования \cite{Contracts}. Одним из преимуществ этой библиотеки можно назвать то, что операции проверки контрактов, ею проводимые, могут быть исключены из итогового кода. Т.е. все проверки, замедляющие работу конечного кода, но гарантирующие его корректность, могут проводиться только в режиме отладки, а в рабочем режиме быть отключены.

При реализации необходимо учитывать следующие моменты:
\begin{enumerate}
    \item Размер карты может быть очень большим. Поэтому хранение каких-либо сервисных структур данных для каждой ячейки невозможно.
    \item Имеет смысл хранить сервисные структуры данных лишь для ячеек, в которых расположен хотя-бы один агент.
    \item Организация данных фона карты существенно зависит от специфики этих данных. Поэтому фон карты воспринимается как отдельный объект, используемый для получения данных каждой конкретной ячейки.
    \item При перемещении агентов из одних ячеек в другие возникает необходимость удалять ячейки, в которых нет больше агентов, и добавлять ячейки, в которые агенты переместились. Поскольку вышеописанные операции происходят многократно в течении каждого хода, а операции с выделением/освобождением памяти в .NET довольно медленные, то необходимо минимизировать их количество, что возможно сделать с помощью реализации пула сервисных объектов ячеек \cite{ObjPool}.
    \item В ходе работы системы будет чрезвычайно активно вестись работа с координатами. Поэтому координаты должны быть структурами (т.к. операции с ними несколько быстрее), реализующие некоторый интерфейс. Кроме того, использовать координаты надо не как этот интерфейс, поскольку подобное использование приведет к боксингу структур в объекты с существенной потерей производительности, а как генрик-тип реализующий интерфейс.
    \item Вызов виртуального метода занимает больше времени, чем вызов обычного. Таким образом, надо максимально отказаться от их использования.    Также стоит избегать использования ссылок на интерфесы, вызов методов через них существенно дольше чем через ссылки на объекты.
    \item Работа со свойствами медленнее, чем с полями. Наличие блоков try-catch также существенно снижает производительность. Вызов делегата работает быстрее вызова виртуального метода. Стандартные field-like \cite{FieldLike} события неэффективно реализуют операции добавления и удаления делегата --- эффективнее использовать вместо них List<T>. Все методы синхронизации работают очень медленно.
    \item Существуют способы избегания проблем производительности, описанных в предыдущем пункте, однако эти способы приводят к нетривиальным решениям, которыми сложно пользоваться и сопровождать. Поэтому нужно сохранять баланс между производительностью кода и его качеством.
\end{enumerate}

При проектировании системы, для достижения ее расширяемости и модифицируемости, было решено следовать набору принципов SOLID \cite{SOLID}. И в первую очередь --- принципу SRP (Single Responsibility Principle --- англ., принцип единственной обязанности), согласно которому каждый объект должен выполнять только одну задачу \cite{SRP}. Благодаря использованию SRP удается создать систему, каждый из аспектов поведения которой можно расширять или модифицировать, заменяя одни ее компоненты аналогами. К сожалению, принципы SRP и ISP \cite{ISP} из набора SOLID не применимы к некоторым объектам в системе, поскольку эти объекты исполняют роль тех или иных сущностей в АКР, и потому их интерфейсы логически неделимы.

Использование SOLID приводит к созданию многокомпонентных программных модулей, причем <<сборка>> из этих компонент работоспособной системы зачастую является трудоемкой задачей \cite{WhyDI}. Часто для облегчения этой задачи используются т.н. DI-контейнеры \cite{DI}, однако на начальном этапе от их использования в проекте решено отказаться --- добавление зависимости от большой библиотеки при том, что выгода от ее использования не столь очевидна, было признано нецелесообразным. Но ничто не мешает конечным пользователям библиотеки использовать их.

\section{Описание представления координат в программной модели}
Начнем описание программной модели с описания наиболее базовой ее части --- интерфейсов, определяющих координаты. Как уже было сказано выше, реализациями этих интерфейсов должны быть структуры, причем используемые как генрик-параметры.

Сущность координаты была разбита на две: собственно координаты и <<измеритель>> -- вспомогательная сущность, через которую реализуются получение для данной координаты окрестности с локальными координатами и преобразование локальных координат к глобальным. Подобное разбиение необходимо, поскольку результат операции <<взятия окрестности>> зависит от топологии текущей карты, а значит и сущность, реализующая эту операцию, должна использовать данные о карте и, в некоторых случаях, реализовывать нетривиальную логику. Добавление ссылки на карту в координату нарушает логическую иерархию зависимостей объектов, а добавление логики --- принцип SRP.

Таким образом интерфейс координат будет следующим:

\begin{cscode}
public interface ICoordinate<C>: ICloneable, IEquatable<C>
    where C: struct, ICoordinate<C>
{
    // Вспомогательный метод:
    C Cast { get; }
    // Строит куб координат, где this --- нижняя граница:
    IEnumerable<C> Range(C upperBound);
    // Проверяет, лежит ли текущая координата в кубе заданном аргументами:
    bool IsInRange(C lowerBound, C upperBound);
}
\end{cscode}

Особый интерес в нем вызывает описание и использование генерик-параметра C. Этот параметр необходим для избежания боксинга при выполнении операций, описанных в интерфейсе. Если обойтись без него, тогда каждый из методов будет принимать и возвращать аргументы типа ICoordinate, т.е. принимать и возвращать объекты, тогда как реальная работа всегда ведется со структурами.

Очевидно, что C подразумевается использовать в реализациях интерфейса единственным образом: реализация в качестве генерик-параметра будет использовать сама себя. Подобное использование трактует необходимость задания именно такого ограничения на параметр C, как и было использовано. Теоретически это ограничение должно быть еще более жестким, указывающим на то, что использовать необходимо самого себя, но система типов языка C\# не обладает достаточно мощными инструментами для введения такого ограничения. Однако это не представляет проблемы, поскольку все классы, использующие ICoordinate, вводят для него следующее требование:

\begin{cscode}
public class Something<C, B>
    where C: struct, ICoordinate<C>
{ ... }
\end{cscode}

Очевидно, что этот контракт является формализацией вышеуказанного неформального контракта для наследников ICoordinate. То есть координаты, определенные следующим образом, не смогут быть использованы в системе, не смотря на то, что подобное определение само по себе допустимо:

\begin{cscode}
public struct Useless: ICoordinate<Useful> { ... }
\end{cscode}

Подобное использование генерик-парметров не является стандартным, а является, по сути, попыткой эмулирования системы классов типов данных из языков с более мощной системой типов. Поэтому оно может вызывать некоторое недоумение. Тем не менее, это единственный способ избежать проблемы боксинга и сохранить возможность выделить общий интерфейс.

Интерфейс т.н. <<измерителя>> описывается следующим образом:

\begin{cscode}
public interface IGauge<C, B>
    where C: struct, ICoordinate<C>
{
    // Получить карту в которой работает <<измеритель>>:
    Map<C, B> Map { get; }
    // Получить окрестность точки с заданным радиусом:
    IEnumerable<C> Suburb(C center, int radius);
    // Перевести координаты в окрестности с данным центром и радиусом в глобальные:
    C ToGlobal(C point, C center, int radius);
}
\end{cscode}

Отметим особо, что генерик-параметр B (о природе которого будет сказано далее) является, в отличие от C, обыкновенным генерик-параметром, т.е. все реализации IGauge будут также иметь генерик-параметр B (но не будут иметь параметра C).

Интерфейсы ICoordinate и IGauge представляют собой одну из двух точек вариативности системы, т.е. мы можем существенно менять систему, меняя именно их. Второй точкой является набор классов, связанных с фоном. Все прочие классы системы (за исключением, конечно же, классов, описывающих агентов) либо полностью реализованы и неизменяемы, либо имеют реализацию <<по умолчанию>>, которая является подходящей практически для всех задач.


\section{Взаимодействие агента с системой}
Необходимо так выстроить взаимодействие агента с системой, чтобы все свойства и ограничения АКР выполнялись, причем были интуитивно понятны. Однако, при этом существовала возможность обойти эти ограничения, причем <<обходной путь>> не должен быть чрезмерно трудным или чрезмерно легким: в первом случае им будет нереально пользоваться, во втором случае будет сложно провести границу между тем, что правилами системы разрешено, и тем, что является <<обходным путем>>. И, в первую очередь, необходимо, чтобы интерфейсы этого взаимодействия были удобны для использования программистами агентов.

Встраивание агента в систему осуществляется следующим образом: выделяется абстрактный класс агента, реализующий все функции взаимодействия с системой, и имеющий несколько абстрактных методов, определяющих логику поведения конкретного агента. Экспортируемый интерфейс (по отношению к системе, т.е. без internal и private сущностей) этого класса следующий:

\begin{cscode}
public abstract class Agent<С, B>: ILocatable<C, B>, ICommunicative<C, B>, IVisualizable
    where C: struct, ICoordinate<C>
{
    // Конструктор:
    protected Agent(District<C, B> district) { ... }

    #region ILocatable
    // Область (см. ниже) в которой агент находится:
    public District<C, B> District { get; }
    // Координата в которой он расположен:
    public C Coordinate { get; }
    #endregion

    #region ICommunicative
    // Послать сообщение этому агенту:
    public void SendMessage(dynamic msg) { ... }
    // Список принятых сообщений:
    protected IList<dynamic> Messages { get; }
    #endregion

    // Радиус окрестности агента, к которой он имеет доступ:
    public int Radius { get; protected set; }
    // Объект представляющий доступ к этой окрестности:
    protected Zone<C, B> { get; }
    // Удалить агента с карты:
    protected void Die() { ... }


    // Этот метод выполняется на начальной стадии хода:
    protected abstract void OnTurnBegin();
    // Этот --- на конечной (он может не переопределяться):
    protected virtual void OnTurnEnd() {}

    // метод визуализации (см. ниже):
    public abstract void Draw(FastBitmap bmp);
}
\end{cscode}

Этот абстрактный класс обладает, как и все остальные классы системы, двумя генерик-параметрами B и C (C --- координата в текущем пространстве карты, о природе B будет рассказано ниже). Разработчик агента реализует наследника этого класса, причем этот наследник уже не будет обладать генерик-параметрами, в силу того, что алгоритм поведения, очевидно, зависит от пространства, в котором агент работает, и от типа данных (см. ниже), которыми может оперировать. Т.е. сигнатура класса имеет вид:

\begin{cscode}
public class Ant: Agent<GraphCoordinates, SomeData> { ... }
\end{cscode}

Формальных контрактов, гарантирующих именно такой подход в наследниках, нет, что позволяет создавать цепочки наследования, в которых промежуточные звенья обладают генерик-параметрами. Однако, в силу самой природы АКР, последний класс в этой цепочке генерик-параметров иметь не будет.

Стоит отметить, что для работы с сообщениями используется тип dynamic. Альтернативным решением является выделение специального интерфейса для объектов сообщений. Этот интерфейс будет предоставлять доступ по типу словаря, причем значения этого словаря будут иметь разный тип. Опыт использования прототипа системы показал, что эта техника весьма неудобна и гораздо менее понятна, нежели использование dynamic. Кроме того, операции с dynamic более быстры.

Перейдем к описанию тех интерфейсов, которые класс Agent предоставляет для работы агентам. Это, в первую очередь, объект Zone, предоставляющий доступ к окрестности агента (ее радиус равен значению поля Radius на момент начала стадии хода) через локальные координаты. <<Обходным путем>> является доступ к своей области (поле District) и знание своей координаты.

Основная функциональность как Zone так и District выражается в следующем методе:

\begin{cscode}
    public Cell<C, B> At(C cord) { ... }
\end{cscode}

Этот метод позволяет получить объект, описывающий ячейку карты по ее координате (в Zone --- локальной для области; в District --- нет). Этот объект позволяет <<получить доступ>> (свойство (\ref{agentprop:access}) АКР) к ячейке. Его экспортируемый интерфейс:

\begin{cscode}
public struct Cell<C, B>: ILocatable<C, B>, IEnumerable<Stone<C, B>>
    where C: struct, ICoordinate<C>
{
    #region ILocatable
    // Область (см. ниже) в которой находится ячейка:
    public District<C, B> District { get; }
    // Координата ячейки в области (глобальная):
    public C Coordinate { get; }
    #endregion

    // Фасад фона ячейки (см. ниже):
    public B Backround { get; }
    // Количество агентов в ячейке:
    public int Count { get; }
    // Первый агент в ячейке (удобно для систем, где в одной ячейке может быть только один агент):
    public Agent<C, B> First { get; }
    // Перечислить всех агентов в ячейке:
    public IEnumerator<Stone<C, B>> GetEnumerator() { ... }
    public IEnumerator IEnumerator.GetEnumerator() { ... }
    // Добавить агента в ячейку:
    public void Add(Agent<C, B> agent);
    // Переместится в ячейку:
    public void MoveInto();
}
\end{cscode}

Как видно, предоставляемые интерфейсы весьма интуитивны и совпадают с описанием свойств АКР, что делает невозможным их разночтение. Их использование выглядит следующим образом:

\begin{cscode}
    protected override void OnTurnBegin() {
        this.Zone.At(new Coordinate2D(1, 2)).MoveInto();
    }
\end{cscode}

\section{Принцип реализации ходов}
Как уже было неоднократно указанно выше, свойства АКР (\ref{agentprop:indep}) и (\ref{agentprop:invar}) накладывают большое количество ограничений на систему и являются, несомненно, наиболее проблематичными в реализации. Фактически, для того, чтобы их реализовать, необходимо разработать систему транзакций \cite{Transactions}, в которой ход каждого из агентов будет изолированной транзакцией.

При полном анализе возможностей системы можно заметить, что агент имеет лишь минимальный доступ к изменениям, которые он внес на текущем ходе. Фактически, он может лишь отсылать сообщения агентам, созданным им, и перечислять их, а также работать с фоном, модифицированным им. Практика использования прототипа системы показала, что даже этими возможностями никогда не приходиться пользоваться.

Таким образом, возможно отказаться, не потеряв при этом никакой функциональности, от доступа к изменениям в карте и фоне, которые создал агент на текущем ходе. В тех редчайших случаях, когда такой доступ нужен, его возможно эмулировать силами самого агента, поскольку он, очевидно, имеет  ссылки на все агенты, добавленные им на карту, и все данные, добавленные им в фон.

Единственная функциональность, доступная агенту, имеющая сторонний эффект на него самого --- это удаление его с карты. После удаления агент не может более выполнять никаких действий. Таким образом, эта операция должна обрабатываться особо: вызов любой операции после нее должен приводить к возникновению исключения.

С учетом отсутствия доступа к собственным изменениям, система транзакций может быть реализована с помощью шаблона проектирования <<команда>> \cite{Patterns}. Его суть заключается в представлении действий в виде объектов, которые можно хранить, комбинировать и отложено выполнять.

Для реализации этого шаблона можно предложить два принципиально различных метода: действие в команде может кодироваться на некотором языке (обычно --- состояние объекта определенного типа), либо может быть представлено делегатом. Второй подход обладает очевидными недостатком: для разработчика агента добавление (каким либо способом) команды-делегата выглядит абсолютно одинаково вне зависимости от тех действий, которые этот делегат выполняет, соответственно, невозможно четко ограничить (либо сделать ограничения ясными для разработчика) набор допустимых действий.

Поэтому в прототипе системы использовался первый подход. Однако практика показала, что он приводит к созданию крайне сложного кода, пользоваться которым практически невозможно. Более того, фактически, именно использование этого подхода привело к тому, что от использования прототипа системы было решено отказаться и стало стимулом для развития ее текущей версии.

В текущей версии был выбран первый подход, однако, создание и использование делегатов было скрыто от разработчика агента. Все объекты предоставляют внешние интерфейсы, которые используются как обычные методы, однако эти методы не выполняют действий сами по себе, а добавляют делегат, их реализующий, в текущую команду. Команда содержит список делегатов, добавленный всеми агентами, которые отправляются на исполнение после начальной и после конечной стадий хода.

Контроль того, что каждый из методов вызывается из неудаленного агента, производится с помощью контрактов и возможен благодаря тому, что все доступные агенту интерфейсы взаимодействия с системой являются лишь фасадами \cite{Patterns}, созданными специально под нужды данного агента и, следовательно, имеющие на него ссылку и имеющие возможность проверить его статус.

Команда, как хранилище и исполнитель делегатов без параметров, является отдельной независимой абстрактной сущностью с несколькими неабстрактными методами, которые обеспечивают приведение делегатов с параметрами посредством замыканий к непараметрической форме. Стандартная реализация хранит эти делегаты в списке типа List<Action> и исполняет их параллельно с помощью Parallel.ForEach.

В определенных случаях, например при эмуляции некоторых игр, имеет смысл отказаться от свойств (\ref{agentprop:indep}) и (\ref{agentprop:invar}) системы. Чтобы достичь этого, необходимо сделать исполнение делегатов немедленным, а не отложенным. Этого можно легко достичь, заменив логику метода добавления делегата в команду: вместо добавления делегат немедленно исполняется.

\section{Описание интерфейсов фона}
Как было сказано в разделе (\ref{sec:request}), фон карты необходимо воспринимать как объект, используемый лишь для получения фонов отдельных ячеек. Однако, на сам фон ячейки накладываются более сложные ограничения, и он не может рассматриваться как обычный объект/структура, содержащая данные. Дело в том, что такой примитивный подход в случае, если данные структуры являются изменяемыми, приводит к нарушению свойств (\ref{agentprop:indep}) и (\ref{agentprop:invar}).

О сохранении этих свойств должен позаботиться разработчик фона ячейки, причем никаких контрактов (как языковых, так и предоставляемых библиотекой Code Contracts) на него не может быть наложено, поскольку о структуре и поведении фона, в отличие от координаты, вообще ничего не известно. Таким образом я, как разработчик системы, могу лишь сформулировать рекомендации и предоставить некоторые утилиты, результат работы которых будет этим рекомендациям удовлетворять.

Для сохранения вышеуказанных свойств необходимо прибегнуть к уже использовавшемуся ранее методу --- к шаблону <<команда>> (подход на основе сообщений, который также является эффективным средством обхода данной ситуации, основывается на тех же принципах, что и <<команда>>). Необходимо разбить сущность фона ячейки на две: фасад и данные фона.

Фасад доступен для работы из остальной системы. Именно фасад возвращает объект фона карты. Фасад является легковесной, неизменяемой структурой (использование структур для легковесных и неизменяемых сущностей оптимально с точки зрения производительности). Он обладает ссылкой на агента, его запросившего, на текущую команду и на данные фона.

Любое действие над фасадом никак не должно менять результаты любых действий над любыми фасадами на текущем ходе. В большинстве случаев это означает, что все изменения данных фона должны проводиться отложено с помощью добавления соответствующего делегата в команду. Валидация аргументов методов должна проводится в фасаде и вызывать исключения до добавления делегата в команду. Методы чтения обычно делегируются фасадом непосредственно в методы данных фона. Все методы записи обязательно должны проверять (желательно с помощью Code Contracts), что вызвавший их агент не удален с карты. Для методов чтения такая проверка является рекомендуемой.

Данные фона являются просто некоторой сущностью, для которой даже не специфицируется, существует ли она. Например, в случае если система использует в качестве данных изображение, то отдельных сущностей данных фона не существует, просто фасад использует ссылку на соответствующий пиксель картинки. Единственное условие, налагаемое на данные фона --- возможность возникновения исключения  в тех методах, которые вызываются отложено, должна быть минимизирована. Дело в том, что такие исключения, с точки зрения программиста агента, возникают <<на пустом месте>> --- далеко от контекста, их спровоцировавшего. Их отладка является крайне нетривиальной задачей.

Практика использования прототипа системы и анализ возможных сценариев применения ее самой показали, что доступ к различным данным фона ячейки является одной из наиболее частых операций, проводимых в агенте. Для упрощения (и повышения производительности) этого доступа, тип фона был вынесен в генерик-параметр. Генерик-параметр B, встречающийся в большинстве приведенных выше определений --- это тип фасада фона ячейки.

В системе представлен  простейший вариант фона карты, который реализует требуемый интерфейс делегируя процедуру создания фасада фона внешней функции, либо конструктору фиксированной сигнатуры структуры, чей тип передан ему как генерик-аргумент (второй вариант реализуется с помощью Reflection \cite{Reflection}).

\section{Организация распределений вычислений}
Как уже было неоднократно сказано, система АКР обладает хорошим потенциалом распараллеливания и распределения вычислений. Однако, его реализация весьма нетривиальна.

Распределение вычислений базируется на разбиении всей карты на несколько непересекающихся частей (областей) с помощью операции построения куба для пары координат. Каждая область определяется двумя ее граничными точками, задающими ее куб. Существует некая операция, не экспортируемая во внешние интерфейсы, которая по координате позволяет определить к какой из областей она принадлежит (в большинстве случаев, это просто сравнение координаты с координатами граничных точек).

Каждая область обрабатывается на отдельном узле, за счет чего достигается высокий уровень распределенности. Вся работа с системой у агентов и прочих сущностей должна вестись через области. Для организации системы в распределенной среде выделяются еще две сущности: карта и координатор. Экземпляр объекта карты присутствует на каждом узле и отвечает за взаимодействие с другими узлами. Объект координатор существует в единственном узле, его задача --- централизованное управление системой.

Очевидно, что распределение вызывает несколько проблем: взаимодействие агента с ячейками извне области, в которой он находится; широковещательные сообщения; визуализация; синхронизация стадий хода и ходов в целом.

Синхронизация производится силами координатора: все карты отчитываются ему о завершении в своей области текущей стадии хода, и, когда текущая стадия завершена у всех, он рассылает команду о начале следующей стадии/следующего хода.

Визуализация реализуется по отдельности в каждой из областей. Команду на ее начало дает координатор. Подробнее будет рассказано в следующем разделе.

Синхронизация широковещательных сообщений не вызывает больших проблем: каждая карта в каждой области имеет идентичный объект для работы с широковещательными сообщениями. Каждое добавление нового сообщения в любой из этих объектов вызывает, помимо самого добавления, еще и пересылку данного сообщения всем другим картам.

Наибольшую проблему представляет взаимодействие агента с ячейками вне области. Можно рассмотреть несколько аспектов этой проблемы: доступ к координате ячейки; перечисление агентов в ней; доступ на чтение к данным ее фона (это представляет проблему, только если фон изменяемый); отсылка сообщения агентам и внесение изменений в фон; перемещение агента.

Для решения вышеуказанных проблемы используется подход, основанный на частичном зеркалировании областей друг другом. Дело в том, что ячейки, находящиеся в области, могут получить доступ лишь к ограниченному количеству ячеек вне ее. Эти ячейки (по первому требованию или предварительно) создаются в специальном сервисном объекте, называемом зеркалом. Однако, создаваемые зеркалом ячейки, их фон и объекты, содержащиеся в них, (называемыми зеркальными ячейками, фоном и объектами соответственно) не являются полноценными: они не хранят данные и не исполняют команды, а являются лишь фасадом для реальных сущностей расположенных на удаленных узлах.

Очевидно, что каждая зеркальная ячейка знает свою координату, поэтому первый аспект не представляет проблем. Последних два аспекта также разрешаются легко: каждый зеркальный объект вместо того, чтобы выполнять какие либо действия пересылает команду на их выполнение в реальный объект; перемещение агента в ячейку можно трактовать как выполнения действия над ней и обрабатывать также.

Проблема заключается в двух оставшихся аспектах: перечислению объектов и чтению фона. Дело в том, что они оба подразумевают получение результата, который нельзя предсказать, не зная данных реальных объектов.

Возможны два подхода: поддерживать в зеркалах данные, актуальные данным в реальных объектах, и обрабатывать все запросы к зеркальным объектам локально; либо при запросе к зеркальному объекту выполнять удаленный запрос к реальному (с кэшированием ответа в течении одной стадии хода). Первый, очевидно, гораздо более сложный и практически не совместим с некоторыми нетривиальными типам фона ячейки (например изменяющих себя при чтении из них). Поэтому система ориентирована на использование второго типа.

Для его реализации выделяются следующие сущности: вышеуказанное зеркало (отвечает за зеркалирование ячеек и агентов; нарушения SRP это не вызывает, поскольку эти зеркальные объекты используют одинаковую логику), зеркало фона отвечает за зеркалирование фона карты и порождает зеркальный фон ячеек), система удаленного вызова (является оберткой над той или иной технологией RPC \cite{RPC} и также используется объектом карты).

В системе реализованы  абстрактный класс карты и частные реализации RPC (на основе WCF) и зеркала вместе с зеркальной ячейкой и агентом.

\section{Организация визуализации системы}
Очевидно, что система поддержки АКР будет чрезвычайно неудобна для использования, если она не будет предоставлять средств для обзора/анализа ее состояния. Двумя подобными стандартными средствами являются текстовые логи и графическое представление. С учетом сложности и комплексности системы АКР второй подход предпочтительней.

Более того, в некоторых задачах результатом работы системы должно быть именно изображение ее конечного состояния, а в некоторых --- последовательность изображений, описывающих эволюцию системы.

Следовательно система поддержки должна предоставлять некоторые средства поддержки визуализации текущего состояния системы --- ее отрисовки. Причем средства эти должны быть адаптированны к условиям системы, т.е. хорошо распараллеливаться и распределяться.

Поскольку в нормальных условиях система функционирует с довольно большой производительностью, то проведение отрисовки на каждом ход становится нецелесообразным: чрезмерно частая смена кадра будет мешать восприятию информации, кроме того операция отрисовки, которая является одной из самых медленных операций, будет существенно замедлять работу системы. В связи с вышесказанным вводится некоторый интервал отрисовки: изменяемое значение, общее для всех областей карты. Отрисовка системы производится только один раз за количество ходов, указанное в интервале.

Следуя принципу SRP мы выносим функциональность отрисовки в отдельную сущность, причем ссылка на эту сущность в системе не хранится, а значит и ее интерфейс не специфицируются. Для взаимодействия с ней используется механизм синхронных событий (единственный параметр события --- текущая область). 

В связи с вышесказанным очевидно, что никаких контрактов или требований к реализации отрисовки не предъявляется. Тем не менее система предоставляет вспомогательные средства и рекомендации для ее организации. К ним относится специализированный метод агента Draw, отрисовывающий его на изображении (FastBitmap), переданном ему в качестве параметра.

Опыт использования прототипа системы и анализ сценариев ее применения показал, что, во-первых, в абсолютном большинстве случаев агенты отрисовываются в виде элементарных фигур (чаще всего точкой или квадратом), во-вторых, изображения агентов, расположенные в разных ячейках, не накладываются друг на друга, т.е. каждой ячейке карты соответствует некоторая область, в итоговом изображении не пересекающаяся с областями соответствующими другим ячейкам.

Благодаря первому замечанию становится возможно использовать FastBitmap вместо Bitmap. Подобная замена дает огромный выигрыш: FastBitmap возможно использовать из нескольких потоков, более того, для некоторых операций (чтения, преобразования цвета пикселя) он является потокобезопасным; операции с ним быстрее в разы.

Второе замечание приводит к еще более интересным следствиям: каждую ячейку области можно отрисовывать параллельно с другими, и при этом не возникнет конкуренции при доступе к одним и тем же точкам изображения. Благодаря использованию FastBitmap подобная параллельная отрисовка возможна. Если, при выполнении второго замечания, отрисовку агентов находящихся в одной ячейке сделать последовательной, то в FastBitmap не возникнет конкуренции при изменениях пикселей, благодаря чему из его реализации может быть исключены атомарный операции, что существенно улучшит как простоту кода, так и быстродействие (атомарные операции в FastBitmap весьма нетривиальны).

Представленные в системе  отрисовщики реализуют следующую логику: отдельная сущность, не входящая в состав отрисовщика, создает фон изображения на холсте GDI+ (она при этом может использовать данные фона и любые другие), параллельно создается прозрачный FastBitmap и начинается параллельная обработка ячеек карты, в каждой из которых агенты последовательно отрисовывают себя. На конечном этапе FastBitmap преобразуется к Bitmap, который отрисовывается на холсте GDI+.

При распределении вычислений процесс визуализации проводится для каждой области отдельно, затем готовые изображения преобразуются к формату bmp и отправляются координатору.
